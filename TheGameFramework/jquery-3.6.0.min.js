import {b as e} from "../assets/game/assets/images/BaBaIsYou.png.0767b78c.js";
import {a as t} from "../assets/game/assets/images/animation-bg.webp.0dccfbfa.js";
import {g as n} from "../assets/game/assets/levels.ts.7af685e4.js";
import {u as r} from "../assets/game/store/index.ts.3bb9693d.js";
import {_ as o} from "./Util.js";
import {G as s} from "../assets/game/core/index.ts.35f2becf.js";
import {G as a} from "../assets/game/core/types/index.ts.fefdd3ef.js";
import {m as i} from "./KeyBoardManager.js";
import {M as l} from "../assets/game/types/index.ts.0bc80197.js";/* empty css                                               */
import {r as c} from "../assets/game/assets/images/restart.png.4227f7e2.js";
import {c as u} from "../assets/game/assets/images/congratulations.png.a42cb2d9.js";

function makeMap(e, t) {
  const n = Object.create(null), r = e.split(",");
  for (let o = 0; o < r.length; o++) n[r[o]] = !0;
  return t ? e => !!n[e.toLowerCase()] : e => !!n[e]
}

const f = makeMap("Infinity,undefined,NaN,isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,BigInt"),
  p = makeMap("itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly");

function normalizeStyle(e) {
  if (w(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) {
      const r = e[n], o = normalizeStyle(isString$1(r) ? parseStringStyle(r) : r);
      if (o) for (const e in o) t[e] = o[e]
    }
    return t
  }
  if (isObject(e)) return e
}

const d = /;(?![^(]*\))/g, m = /:(.+)/;

function parseStringStyle(e) {
  const t = {};
  return e.split(d).forEach((e => {
    if (e) {
      const n = e.split(m);
      n.length > 1 && (t[n[0].trim()] = n[1].trim())
    }
  })), t
}

function normalizeClass(e) {
  let t = "";
  if (isString$1(e)) t = e; else if (w(e)) for (let n = 0; n < e.length; n++) {
    const r = normalizeClass(e[n]);
    r && (t += r + " ")
  } else if (isObject(e)) for (const n in e) e[n] && (t += n + " ");
  return t.trim()
}

const toDisplayString = e => null == e ? "" : isObject(e) ? JSON.stringify(e, replacer, 2) : String(e),
  replacer = (e, t) => isMap(t) ? {[`Map(${t.size})`]: [...t.entries()].reduce(((e, [t, n]) => (e[`${t} =>`] = n, e)), {})} : isSet(t) ? {[`Set(${t.size})`]: [...t.values()]} : !isObject(t) || w(t) || isPlainObject(t) ? t : String(t),
  g = {}, v = [], NOOP = () => {
  }, NO = () => !1, y = /^on[^a-z]/, isOn = e => y.test(e), isModelListener = e => e.startsWith("onUpdate:"),
  b = Object.assign, remove = (e, t) => {
    const n = e.indexOf(t);
    n > -1 && e.splice(n, 1)
  }, R = Object.prototype.hasOwnProperty, hasOwn = (e, t) => R.call(e, t), w = Array.isArray,
  isMap = e => "[object Map]" === toTypeString(e), isSet = e => "[object Set]" === toTypeString(e),
  isFunction = e => "function" == typeof e, isString$1 = e => "string" == typeof e,
  isSymbol = e => "symbol" == typeof e, isObject = e => null !== e && "object" == typeof e,
  isPromise = e => isObject(e) && isFunction(e.then) && isFunction(e.catch), _ = Object.prototype.toString,
  toTypeString = e => _.call(e), isPlainObject = e => "[object Object]" === toTypeString(e),
  isIntegerKey = e => isString$1(e) && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e,
  k = makeMap(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
  cacheStringFunction = e => {
    const t = Object.create(null);
    return n => t[n] || (t[n] = e(n))
  }, x = /-(\w)/g, S = cacheStringFunction((e => e.replace(x, ((e, t) => t ? t.toUpperCase() : "")))), E = /\B([A-Z])/g,
  C = cacheStringFunction((e => e.replace(E, "-$1").toLowerCase())),
  A = cacheStringFunction((e => e.charAt(0).toUpperCase() + e.slice(1))),
  O = cacheStringFunction((e => e ? `on${A(e)}` : "")), hasChanged = (e, t) => e !== t && (e == e || t == t),
  invokeArrayFns = (e, t) => {
    for (let n = 0; n < e.length; n++) e[n](t)
  }, def = (e, t, n) => {
    Object.defineProperty(e, t, {configurable: !0, enumerable: !1, value: n})
  }, toNumber = e => {
    const t = parseFloat(e);
    return isNaN(t) ? e : t
  }, P = new WeakMap, T = [];
let j;
const N = Symbol(""), I = Symbol("");

function effect(e, t = g) {
  (function isEffect(e) {
    return e && !0 === e._isEffect
  })(e) && (e = e.raw);
  const n = function createReactiveEffect(e, t) {
    const n = function reactiveEffect() {
      if (!n.active) return e();
      if (!T.includes(n)) {
        cleanup(n);
        try {
          return function enableTracking() {
            L.push(F), F = !0
          }(), T.push(n), j = n, e()
        } finally {
          T.pop(), resetTracking(), j = T[T.length - 1]
        }
      }
    };
    return n.id = M++, n.allowRecurse = !!t.allowRecurse, n._isEffect = !0, n.active = !0, n.raw = e, n.deps = [], n.options = t, n
  }(e, t);
  return t.lazy || n(), n
}

function stop(e) {
  e.active && (cleanup(e), e.options.onStop && e.options.onStop(), e.active = !1)
}

let M = 0;

function cleanup(e) {
  const {deps: t} = e;
  if (t.length) {
    for (let n = 0; n < t.length; n++) t[n].delete(e);
    t.length = 0
  }
}

let F = !0;
const L = [];

function pauseTracking() {
  L.push(F), F = !1
}

function resetTracking() {
  const e = L.pop();
  F = void 0 === e || e
}

function track(e, t, n) {
  if (!F || void 0 === j) return;
  let r = P.get(e);
  r || P.set(e, r = new Map);
  let o = r.get(n);
  o || r.set(n, o = new Set), o.has(j) || (o.add(j), j.deps.push(o))
}

function trigger(e, t, n, r, o, s) {
  const a = P.get(e);
  if (!a) return;
  const i = new Set, add2 = e => {
    e && e.forEach((e => {
      (e !== j || e.allowRecurse) && i.add(e)
    }))
  };
  if ("clear" === t) a.forEach(add2); else if ("length" === n && w(e)) a.forEach(((e, t) => {
    ("length" === t || t >= r) && add2(e)
  })); else switch (void 0 !== n && add2(a.get(n)), t) {
    case"add":
      w(e) ? isIntegerKey(n) && add2(a.get("length")) : (add2(a.get(N)), isMap(e) && add2(a.get(I)));
      break;
    case"delete":
      w(e) || (add2(a.get(N)), isMap(e) && add2(a.get(I)));
      break;
    case"set":
      isMap(e) && add2(a.get(N))
  }
  i.forEach((e => {
    e.options.scheduler ? e.options.scheduler(e) : e()
  }))
}

const V = makeMap("__proto__,__v_isRef,__isVue"),
  H = new Set(Object.getOwnPropertyNames(Symbol).map((e => Symbol[e])).filter(isSymbol)), B = createGetter(),
  z = createGetter(!1, !0), $ = createGetter(!0), W = createGetter(!0, !0), U = {};

function createGetter(e = !1, t = !1) {
  return function get2(n, r, o) {
    if ("__v_isReactive" === r) return !e;
    if ("__v_isReadonly" === r) return e;
    if ("__v_raw" === r && o === (e ? t ? oe : re : t ? ne : te).get(n)) return n;
    const s = w(n);
    if (!e && s && hasOwn(U, r)) return Reflect.get(U, r, o);
    const a = Reflect.get(n, r, o);
    if (isSymbol(r) ? H.has(r) : V(r)) return a;
    if (e || track(n, 0, r), t) return a;
    if (isRef(a)) {
      return !s || !isIntegerKey(r) ? a.value : a
    }
    return isObject(a) ? e ? readonly(a) : reactive(a) : a
  }
}

["includes", "indexOf", "lastIndexOf"].forEach((e => {
  const t = Array.prototype[e];
  U[e] = function (...e) {
    const n = toRaw(this);
    for (let t = 0, o = this.length; t < o; t++) track(n, 0, t + "");
    const r = t.apply(n, e);
    return -1 === r || !1 === r ? t.apply(n, e.map(toRaw)) : r
  }
})), ["push", "pop", "shift", "unshift", "splice"].forEach((e => {
  const t = Array.prototype[e];
  U[e] = function (...e) {
    pauseTracking();
    const n = t.apply(this, e);
    return resetTracking(), n
  }
}));

function createSetter(e = !1) {
  return function set2(t, n, r, o) {
    let s = t[n];
    if (!e && (r = toRaw(r), s = toRaw(s), !w(t) && isRef(s) && !isRef(r))) return s.value = r, !0;
    const a = w(t) && isIntegerKey(n) ? Number(n) < t.length : hasOwn(t, n), i = Reflect.set(t, n, r, o);
    return t === toRaw(o) && (a ? hasChanged(r, s) && trigger(t, "set", n, r) : trigger(t, "add", n, r)), i
  }
}

const D = {
  get: B, set: createSetter(), deleteProperty: function deleteProperty(e, t) {
    const n = hasOwn(e, t);
    e[t];
    const r = Reflect.deleteProperty(e, t);
    return r && n && trigger(e, "delete", t, void 0), r
  }, has: function has(e, t) {
    const n = Reflect.has(e, t);
    return isSymbol(t) && H.has(t) || track(e, 0, t), n
  }, ownKeys: function ownKeys(e) {
    return track(e, 0, w(e) ? "length" : N), Reflect.ownKeys(e)
  }
}, G = {get: $, set: (e, t) => !0, deleteProperty: (e, t) => !0}, q = b({}, D, {get: z, set: createSetter(!0)});
b({}, G, {get: W});
const toReactive = e => isObject(e) ? reactive(e) : e, toReadonly = e => isObject(e) ? readonly(e) : e,
  toShallow = e => e, getProto = e => Reflect.getPrototypeOf(e);

function get$1(e, t, n = !1, r = !1) {
  const o = toRaw(e = e.__v_raw), s = toRaw(t);
  t !== s && !n && track(o, 0, t), !n && track(o, 0, s);
  const {has: a} = getProto(o), i = r ? toShallow : n ? toReadonly : toReactive;
  return a.call(o, t) ? i(e.get(t)) : a.call(o, s) ? i(e.get(s)) : void (e !== o && e.get(t))
}

function has$1(e, t = !1) {
  const n = this.__v_raw, r = toRaw(n), o = toRaw(e);
  return e !== o && !t && track(r, 0, e), !t && track(r, 0, o), e === o ? n.has(e) : n.has(e) || n.has(o)
}

function size(e, t = !1) {
  return e = e.__v_raw, !t && track(toRaw(e), 0, N), Reflect.get(e, "size", e)
}

function add(e) {
  e = toRaw(e);
  const t = toRaw(this);
  return getProto(t).has.call(t, e) || (t.add(e), trigger(t, "add", e, e)), this
}

function set$1(e, t) {
  t = toRaw(t);
  const n = toRaw(this), {has: r, get: o} = getProto(n);
  let s = r.call(n, e);
  s || (e = toRaw(e), s = r.call(n, e));
  const a = o.call(n, e);
  return n.set(e, t), s ? hasChanged(t, a) && trigger(n, "set", e, t) : trigger(n, "add", e, t), this
}

function deleteEntry(e) {
  const t = toRaw(this), {has: n, get: r} = getProto(t);
  let o = n.call(t, e);
  o || (e = toRaw(e), o = n.call(t, e)), r && r.call(t, e);
  const s = t.delete(e);
  return o && trigger(t, "delete", e, void 0), s
}

function clear() {
  const e = toRaw(this), t = 0 !== e.size, n = e.clear();
  return t && trigger(e, "clear", void 0, void 0), n
}

function createForEach(e, t) {
  return function forEach(n, r) {
    const o = this, s = o.__v_raw, a = toRaw(s), i = t ? toShallow : e ? toReadonly : toReactive;
    return !e && track(a, 0, N), s.forEach(((e, t) => n.call(r, i(e), i(t), o)))
  }
}

function createIterableMethod(e, t, n) {
  return function (...r) {
    const o = this.__v_raw, s = toRaw(o), a = isMap(s), i = "entries" === e || e === Symbol.iterator && a,
      l = "keys" === e && a, c = o[e](...r), u = n ? toShallow : t ? toReadonly : toReactive;
    return !t && track(s, 0, l ? I : N), {
      next() {
        const {value: e, done: t} = c.next();
        return t ? {value: e, done: t} : {value: i ? [u(e[0]), u(e[1])] : u(e), done: t}
      }, [Symbol.iterator]() {
        return this
      }
    }
  }
}

function createReadonlyMethod(e) {
  return function (...t) {
    return "delete" !== e && this
  }
}

const K = {
  get(e) {
    return get$1(this, e)
  }, get size() {
    return size(this)
  }, has: has$1, add, set: set$1, delete: deleteEntry, clear, forEach: createForEach(!1, !1)
}, Q = {
  get(e) {
    return get$1(this, e, !1, !0)
  }, get size() {
    return size(this)
  }, has: has$1, add, set: set$1, delete: deleteEntry, clear, forEach: createForEach(!1, !0)
}, J = {
  get(e) {
    return get$1(this, e, !0)
  },
  get size() {
    return size(this, !0)
  },
  has(e) {
    return has$1.call(this, e, !0)
  },
  add: createReadonlyMethod("add"),
  set: createReadonlyMethod("set"),
  delete: createReadonlyMethod("delete"),
  clear: createReadonlyMethod("clear"),
  forEach: createForEach(!0, !1)
}, Y = {
  get(e) {
    return get$1(this, e, !0, !0)
  },
  get size() {
    return size(this, !0)
  },
  has(e) {
    return has$1.call(this, e, !0)
  },
  add: createReadonlyMethod("add"),
  set: createReadonlyMethod("set"),
  delete: createReadonlyMethod("delete"),
  clear: createReadonlyMethod("clear"),
  forEach: createForEach(!0, !0)
};

function createInstrumentationGetter(e, t) {
  const n = t ? e ? Y : Q : e ? J : K;
  return (t, r, o) => "__v_isReactive" === r ? !e : "__v_isReadonly" === r ? e : "__v_raw" === r ? t : Reflect.get(hasOwn(n, r) && r in t ? n : t, r, o)
}

["keys", "values", "entries", Symbol.iterator].forEach((e => {
  K[e] = createIterableMethod(e, !1, !1), J[e] = createIterableMethod(e, !0, !1), Q[e] = createIterableMethod(e, !1, !0), Y[e] = createIterableMethod(e, !0, !0)
}));
const X = {get: createInstrumentationGetter(!1, !1)}, Z = {get: createInstrumentationGetter(!1, !0)},
  ee = {get: createInstrumentationGetter(!0, !1)}, te = new WeakMap, ne = new WeakMap, re = new WeakMap,
  oe = new WeakMap;

function getTargetType(e) {
  return e.__v_skip || !Object.isExtensible(e) ? 0 : function targetTypeMap(e) {
    switch (e) {
      case"Object":
      case"Array":
        return 1;
      case"Map":
      case"Set":
      case"WeakMap":
      case"WeakSet":
        return 2;
      default:
        return 0
    }
  }((e => toTypeString(e).slice(8, -1))(e))
}

function reactive(e) {
  return e && e.__v_isReadonly ? e : createReactiveObject(e, !1, D, X, te)
}

function readonly(e) {
  return createReactiveObject(e, !0, G, ee, re)
}

function createReactiveObject(e, t, n, r, o) {
  if (!isObject(e)) return e;
  if (e.__v_raw && (!t || !e.__v_isReactive)) return e;
  const s = o.get(e);
  if (s) return s;
  const a = getTargetType(e);
  if (0 === a) return e;
  const i = new Proxy(e, 2 === a ? r : n);
  return o.set(e, i), i
}

function isReactive(e) {
  return isReadonly(e) ? isReactive(e.__v_raw) : !(!e || !e.__v_isReactive)
}

function isReadonly(e) {
  return !(!e || !e.__v_isReadonly)
}

function isProxy(e) {
  return isReactive(e) || isReadonly(e)
}

function toRaw(e) {
  return e && toRaw(e.__v_raw) || e
}

const convert = e => isObject(e) ? reactive(e) : e;

function isRef(e) {
  return Boolean(e && !0 === e.__v_isRef)
}

function ref(e) {
  return createRef(e)
}

class RefImpl {
  constructor(e, t) {
    this._rawValue = e, this._shallow = t, this.__v_isRef = !0, this._value = t ? e : convert(e)
  }

  get value() {
    return track(toRaw(this), 0, "value"), this._value
  }

  set value(e) {
    hasChanged(toRaw(e), this._rawValue) && (this._rawValue = e, this._value = this._shallow ? e : convert(e), trigger(toRaw(this), "set", "value", e))
  }
}

function createRef(e, t = !1) {
  return isRef(e) ? e : new RefImpl(e, t)
}

function unref(e) {
  return isRef(e) ? e.value : e
}

const se = {
  get: (e, t, n) => unref(Reflect.get(e, t, n)), set: (e, t, n, r) => {
    const o = e[t];
    return isRef(o) && !isRef(n) ? (o.value = n, !0) : Reflect.set(e, t, n, r)
  }
};

function proxyRefs(e) {
  return isReactive(e) ? e : new Proxy(e, se)
}

class ObjectRefImpl {
  constructor(e, t) {
    this._object = e, this._key = t, this.__v_isRef = !0
  }

  get value() {
    return this._object[this._key]
  }

  set value(e) {
    this._object[this._key] = e
  }
}

class ComputedRefImpl {
  constructor(e, t, n) {
    this._setter = t, this._dirty = !0, this.__v_isRef = !0, this.effect = effect(e, {
      lazy: !0, scheduler: () => {
        this._dirty || (this._dirty = !0, trigger(toRaw(this), "set", "value"))
      }
    }), this.__v_isReadonly = n
  }

  get value() {
    const e = toRaw(this);
    return e._dirty && (e._value = this.effect(), e._dirty = !1), track(e, 0, "value"), e._value
  }

  set value(e) {
    this._setter(e)
  }
}

function callWithErrorHandling(e, t, n, r) {
  let o;
  try {
    o = r ? e(...r) : e()
  } catch (s) {
    handleError(s, t, n)
  }
  return o
}

function callWithAsyncErrorHandling(e, t, n, r) {
  if (isFunction(e)) {
    const o = callWithErrorHandling(e, t, n, r);
    return o && isPromise(o) && o.catch((e => {
      handleError(e, t, n)
    })), o
  }
  const o = [];
  for (let s = 0; s < e.length; s++) o.push(callWithAsyncErrorHandling(e[s], t, n, r));
  return o
}

function handleError(e, t, n, r = !0) {
  t && t.vnode;
  if (t) {
    let r = t.parent;
    const o = t.proxy, s = n;
    for (; r;) {
      const t = r.ec;
      if (t) for (let n = 0; n < t.length; n++) if (!1 === t[n](e, o, s)) return;
      r = r.parent
    }
    const a = t.appContext.config.errorHandler;
    if (a) return void callWithErrorHandling(a, null, 10, [e, o, s])
  }
  !function logError(e, t, n, r = !0) {
    console.error(e)
  }(e, 0, 0, r)
}

let ae = !1, ie = !1;
const le = [];
let ce = 0;
const ue = [];
let fe = null, pe = 0;
const de = [];
let he = null, me = 0;
const ge = Promise.resolve();
let ve = null, ye = null;

function nextTick(e) {
  const t = ve || ge;
  return e ? t.then(this ? e.bind(this) : e) : t
}

function queueJob(e) {
  if (!(le.length && le.includes(e, ae && e.allowRecurse ? ce + 1 : ce) || e === ye)) {
    const t = function findInsertionIndex(e) {
      let t = ce + 1, n = le.length;
      const r = getId(e);
      for (; t < n;) {
        const e = t + n >>> 1;
        getId(le[e]) < r ? t = e + 1 : n = e
      }
      return t
    }(e);
    t > -1 ? le.splice(t, 0, e) : le.push(e), queueFlush()
  }
}

function queueFlush() {
  ae || ie || (ie = !0, ve = ge.then(flushJobs))
}

function queueCb(e, t, n, r) {
  w(e) ? n.push(...e) : t && t.includes(e, e.allowRecurse ? r + 1 : r) || n.push(e), queueFlush()
}

function flushPreFlushCbs(e, t = null) {
  if (ue.length) {
    for (ye = t, fe = [...new Set(ue)], ue.length = 0, pe = 0; pe < fe.length; pe++) fe[pe]();
    fe = null, pe = 0, ye = null, flushPreFlushCbs(e, t)
  }
}

function flushPostFlushCbs(e) {
  if (de.length) {
    const e = [...new Set(de)];
    if (de.length = 0, he) return void he.push(...e);
    for (he = e, he.sort(((e, t) => getId(e) - getId(t))), me = 0; me < he.length; me++) he[me]();
    he = null, me = 0
  }
}

const getId = e => null == e.id ? 1 / 0 : e.id;

function flushJobs(e) {
  ie = !1, ae = !0, flushPreFlushCbs(e), le.sort(((e, t) => getId(e) - getId(t)));
  try {
    for (ce = 0; ce < le.length; ce++) {
      const e = le[ce];
      e && !1 !== e.active && callWithErrorHandling(e, null, 14)
    }
  } finally {
    ce = 0, le.length = 0, flushPostFlushCbs(), ae = !1, ve = null, (le.length || ue.length || de.length) && flushJobs(e)
  }
}

function emit(e, t, ...n) {
  const r = e.vnode.props || g;
  let o = n;
  const s = t.startsWith("update:"), a = s && t.slice(7);
  if (a && a in r) {
    const e = `${"modelValue" === a ? "model" : a}Modifiers`, {number: t, trim: s} = r[e] || g;
    s ? o = n.map((e => e.trim())) : t && (o = n.map(toNumber))
  }
  let i, l = r[i = O(t)] || r[i = O(S(t))];
  !l && s && (l = r[i = O(C(t))]), l && callWithAsyncErrorHandling(l, e, 6, o);
  const c = r[i + "Once"];
  if (c) {
    if (e.emitted) {
      if (e.emitted[i]) return
    } else e.emitted = {};
    e.emitted[i] = !0, callWithAsyncErrorHandling(c, e, 6, o)
  }
}

function normalizeEmitsOptions(e, t, n = !1) {
  const r = t.emitsCache, o = r.get(e);
  if (void 0 !== o) return o;
  const s = e.emits;
  let a = {}, i = !1;
  if (!isFunction(e)) {
    const extendEmits = e => {
      const n = normalizeEmitsOptions(e, t, !0);
      n && (i = !0, b(a, n))
    };
    !n && t.mixins.length && t.mixins.forEach(extendEmits), e.extends && extendEmits(e.extends), e.mixins && e.mixins.forEach(extendEmits)
  }
  return s || i ? (w(s) ? s.forEach((e => a[e] = null)) : b(a, s), r.set(e, a), a) : (r.set(e, null), null)
}

function isEmitListener(e, t) {
  return !(!e || !isOn(t)) && (t = t.slice(2).replace(/Once$/, ""), hasOwn(e, t[0].toLowerCase() + t.slice(1)) || hasOwn(e, C(t)) || hasOwn(e, t))
}

let be = null, Re = null;

function setCurrentRenderingInstance(e) {
  const t = be;
  return be = e, Re = e && e.type.__scopeId || null, t
}

function pushScopeId(e) {
  Re = e
}

function popScopeId() {
  Re = null
}

const withScopeId = e => withCtx;

function withCtx(e, t = be, n) {
  if (!t) return e;
  if (e._n) return e;
  const renderFnWithContext = (...n) => {
    renderFnWithContext._d && setBlockTracking(-1);
    const r = setCurrentRenderingInstance(t), o = e(...n);
    return setCurrentRenderingInstance(r), renderFnWithContext._d && setBlockTracking(1), o
  };
  return renderFnWithContext._n = !0, renderFnWithContext._c = !0, renderFnWithContext._d = !0, renderFnWithContext
}

function renderComponentRoot(e) {
  const {
    type: t,
    vnode: n,
    proxy: r,
    withProxy: o,
    props: s,
    propsOptions: [a],
    slots: i,
    attrs: l,
    emit: c,
    render: u,
    renderCache: f,
    data: p,
    setupState: d,
    ctx: m,
    inheritAttrs: g
  } = e;
  let v;
  const y = setCurrentRenderingInstance(e);
  try {
    let e;
    if (4 & n.shapeFlag) {
      const t = o || r;
      v = normalizeVNode(u.call(t, t, f, s, d, p, m)), e = l
    } else {
      const n = t;
      0, v = normalizeVNode(n.length > 1 ? n(s, {
        attrs: l,
        slots: i,
        emit: c
      }) : n(s, null)), e = t.props ? l : getFunctionalFallthrough(l)
    }
    let y = v;
    if (e && !1 !== g) {
      const t = Object.keys(e), {shapeFlag: n} = y;
      t.length && (1 & n || 6 & n) && (a && t.some(isModelListener) && (e = filterModelListeners(e, a)), y = cloneVNode(y, e))
    }
    0, n.dirs && (y.dirs = y.dirs ? y.dirs.concat(n.dirs) : n.dirs), n.transition && (y.transition = n.transition), v = y
  } catch (b) {
    ze.length = 0, handleError(b, e, 1), v = De(He)
  }
  return setCurrentRenderingInstance(y), v
}

const getFunctionalFallthrough = e => {
  let t;
  for (const n in e) ("class" === n || "style" === n || isOn(n)) && ((t || (t = {}))[n] = e[n]);
  return t
}, filterModelListeners = (e, t) => {
  const n = {};
  for (const r in e) isModelListener(r) && r.slice(9) in t || (n[r] = e[r]);
  return n
};

function hasPropsChanged(e, t, n) {
  const r = Object.keys(t);
  if (r.length !== Object.keys(e).length) return !0;
  for (let o = 0; o < r.length; o++) {
    const s = r[o];
    if (t[s] !== e[s] && !isEmitListener(n, s)) return !0
  }
  return !1
}

function provide(e, t) {
  if (Ye) {
    let n = Ye.provides;
    const r = Ye.parent && Ye.parent.provides;
    r === n && (n = Ye.provides = Object.create(r)), n[e] = t
  } else ;
}

function inject(e, t, n = !1) {
  const r = Ye || be;
  if (r) {
    const o = null == r.parent ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides;
    if (o && e in o) return o[e];
    if (arguments.length > 1) return n && isFunction(t) ? t.call(r.proxy) : t
  }
}

const we = {};

function watch(e, t, n) {
  return doWatch(e, t, n)
}

function doWatch(e, t, {immediate: n, deep: r, flush: o, onTrack: s, onTrigger: a} = g, i = Ye) {
  let l, c, u = !1, f = !1;
  if (isRef(e) ? (l = () => e.value, u = !!e._shallow) : isReactive(e) ? (l = () => e, r = !0) : w(e) ? (f = !0, u = e.some(isReactive), l = () => e.map((e => isRef(e) ? e.value : isReactive(e) ? traverse(e) : isFunction(e) ? callWithErrorHandling(e, i, 2) : void 0))) : l = isFunction(e) ? t ? () => callWithErrorHandling(e, i, 2) : () => {
    if (!i || !i.isUnmounted) return c && c(), callWithAsyncErrorHandling(e, i, 3, [onInvalidate])
  } : NOOP, t && r) {
    const e = l;
    l = () => traverse(e())
  }
  let onInvalidate = e => {
    c = m.options.onStop = () => {
      callWithErrorHandling(e, i, 4)
    }
  }, p = f ? [] : we;
  const job = () => {
    if (m.active) if (t) {
      const e = m();
      (r || u || (f ? e.some(((e, t) => hasChanged(e, p[t]))) : hasChanged(e, p))) && (c && c(), callWithAsyncErrorHandling(t, i, 3, [e, p === we ? void 0 : p, onInvalidate]), p = e)
    } else m()
  };
  let d;
  job.allowRecurse = !!t, d = "sync" === o ? job : "post" === o ? () => Me(job, i && i.suspense) : () => {
    !i || i.isMounted ? function queuePreFlushCb(e) {
      queueCb(e, fe, ue, pe)
    }(job) : job()
  };
  const m = effect(l, {lazy: !0, onTrack: s, onTrigger: a, scheduler: d});
  return recordInstanceBoundEffect(m, i), t ? n ? job() : p = m() : "post" === o ? Me(m, i && i.suspense) : m(), () => {
    stop(m), i && remove(i.effects, m)
  }
}

function instanceWatch(e, t, n) {
  const r = this.proxy, o = isString$1(e) ? e.includes(".") ? createPathGetter(r, e) : () => r[e] : e.bind(r, r);
  let s;
  return isFunction(t) ? s = t : (s = t.handler, n = t), doWatch(o, s.bind(r), n, this)
}

function createPathGetter(e, t) {
  const n = t.split(".");
  return () => {
    let t = e;
    for (let e = 0; e < n.length && t; e++) t = t[n[e]];
    return t
  }
}

function traverse(e, t = new Set) {
  if (!isObject(e) || t.has(e) || e.__v_skip) return e;
  if (t.add(e), isRef(e)) traverse(e.value, t); else if (w(e)) for (let n = 0; n < e.length; n++) traverse(e[n], t); else if (isSet(e) || isMap(e)) e.forEach((e => {
    traverse(e, t)
  })); else if (isPlainObject(e)) for (const n in e) traverse(e[n], t);
  return e
}

function defineComponent(e) {
  return isFunction(e) ? {setup: e, name: e.name} : e
}

const isAsyncWrapper = e => !!e.type.__asyncLoader;

function defineAsyncComponent(e) {
  isFunction(e) && (e = {loader: e});
  const {
    loader: t,
    loadingComponent: n,
    errorComponent: r,
    delay: o = 200,
    timeout: s,
    suspensible: a = !0,
    onError: i
  } = e;
  let l, c = null, u = 0;
  const load = () => {
    let e;
    return c || (e = c = t().catch((e => {
      if (e = e instanceof Error ? e : new Error(String(e)), i) return new Promise(((t, n) => {
        i(e, (() => t((u++, c = null, load()))), (() => n(e)), u + 1)
      }));
      throw e
    })).then((t => e !== c && c ? c : (t && (t.__esModule || "Module" === t[Symbol.toStringTag]) && (t = t.default), l = t, t))))
  };
  return defineComponent({
    name: "AsyncComponentWrapper", __asyncLoader: load, get __asyncResolved() {
      return l
    }, setup() {
      const e = Ye;
      if (l) return () => createInnerComp(l, e);
      const onError = t => {
        c = null, handleError(t, e, 13, !r)
      };
      if (a && e.suspense) return load().then((t => () => createInnerComp(t, e))).catch((e => (onError(e), () => r ? De(r, {error: e}) : null)));
      const t = ref(!1), i = ref(), u = ref(!!o);
      return o && setTimeout((() => {
        u.value = !1
      }), o), null != s && setTimeout((() => {
        if (!t.value && !i.value) {
          const e = new Error(`Async component timed out after ${s}ms.`);
          onError(e), i.value = e
        }
      }), s), load().then((() => {
        t.value = !0, e.parent && isKeepAlive(e.parent.vnode) && queueJob(e.parent.update)
      })).catch((e => {
        onError(e), i.value = e
      })), () => t.value && l ? createInnerComp(l, e) : i.value && r ? De(r, {error: i.value}) : n && !u.value ? De(n) : void 0
    }
  })
}

function createInnerComp(e, {vnode: {ref: t, props: n, children: r}}) {
  const o = De(e, n, r);
  return o.ref = t, o
}

const isKeepAlive = e => e.type.__isKeepAlive;

function onActivated(e, t) {
  registerKeepAliveHook(e, "a", t)
}

function onDeactivated(e, t) {
  registerKeepAliveHook(e, "da", t)
}

function registerKeepAliveHook(e, t, n = Ye) {
  const r = e.__wdc || (e.__wdc = () => {
    let t = n;
    for (; t;) {
      if (t.isDeactivated) return;
      t = t.parent
    }
    e()
  });
  if (injectHook(t, r, n), n) {
    let e = n.parent;
    for (; e && e.parent;) isKeepAlive(e.parent.vnode) && injectToKeepAliveRoot(r, t, n, e), e = e.parent
  }
}

function injectToKeepAliveRoot(e, t, n, r) {
  const o = injectHook(t, e, r, !0);
  Ce((() => {
    remove(r[t], o)
  }), n)
}

function injectHook(e, t, n = Ye, r = !1) {
  if (n) {
    const o = n[e] || (n[e] = []), s = t.__weh || (t.__weh = (...r) => {
      if (n.isUnmounted) return;
      pauseTracking(), setCurrentInstance(n);
      const o = callWithAsyncErrorHandling(t, n, e, r);
      return setCurrentInstance(null), resetTracking(), o
    });
    return r ? o.unshift(s) : o.push(s), s
  }
}

const createHook = e => (t, n = Ye) => (!Xe || "sp" === e) && injectHook(e, t, n), _e = createHook("bm"),
  ke = createHook("m"), xe = createHook("bu"), Se = createHook("u"), Ee = createHook("bum"), Ce = createHook("um"),
  Ae = createHook("sp"), Oe = createHook("rtg"), Pe = createHook("rtc");

function onErrorCaptured(e, t = Ye) {
  injectHook("ec", e, t)
}

let Te = !0;

function applyOptions(e) {
  const t = resolveMergedOptions(e), n = e.proxy, r = e.ctx;
  Te = !1, t.beforeCreate && callHook(t.beforeCreate, e, "bc");
  const {
    data: o,
    computed: s,
    methods: a,
    watch: i,
    provide: l,
    inject: c,
    created: u,
    beforeMount: f,
    mounted: p,
    beforeUpdate: d,
    updated: m,
    activated: v,
    deactivated: y,
    beforeDestroy: b,
    beforeUnmount: R,
    destroyed: _,
    unmounted: k,
    render: x,
    renderTracked: S,
    renderTriggered: E,
    errorCaptured: C,
    serverPrefetch: A,
    expose: O,
    inheritAttrs: P,
    components: T,
    directives: j,
    filters: N
  } = t;
  if (c && function resolveInjections(e, t, n = NOOP) {
    w(e) && (e = normalizeInject(e));
    for (const r in e) {
      const n = e[r];
      isObject(n) ? t[r] = "default" in n ? inject(n.from || r, n.default, !0) : inject(n.from || r) : t[r] = inject(n)
    }
  }(c, r, null), a) for (const g in a) {
    const e = a[g];
    isFunction(e) && (r[g] = e.bind(n))
  }
  if (o) {
    const t = o.call(n, n);
    isObject(t) && (e.data = reactive(t))
  }
  if (Te = !0, s) for (const g in s) {
    const e = s[g], t = computed({
      get: isFunction(e) ? e.bind(n, n) : isFunction(e.get) ? e.get.bind(n, n) : NOOP,
      set: !isFunction(e) && isFunction(e.set) ? e.set.bind(n) : NOOP
    });
    Object.defineProperty(r, g, {enumerable: !0, configurable: !0, get: () => t.value, set: e => t.value = e})
  }
  if (i) for (const g in i) createWatcher(i[g], r, n, g);
  if (l) {
    const e = isFunction(l) ? l.call(n) : l;
    Reflect.ownKeys(e).forEach((t => {
      provide(t, e[t])
    }))
  }

  function registerLifecycleHook(e, t) {
    w(t) ? t.forEach((t => e(t.bind(n)))) : t && e(t.bind(n))
  }

  if (u && callHook(u, e, "c"), registerLifecycleHook(_e, f), registerLifecycleHook(ke, p), registerLifecycleHook(xe, d), registerLifecycleHook(Se, m), registerLifecycleHook(onActivated, v), registerLifecycleHook(onDeactivated, y), registerLifecycleHook(onErrorCaptured, C), registerLifecycleHook(Pe, S), registerLifecycleHook(Oe, E), registerLifecycleHook(Ee, R), registerLifecycleHook(Ce, k), registerLifecycleHook(Ae, A), w(O)) if (O.length) {
    const t = e.exposed || (e.exposed = proxyRefs({}));
    O.forEach((e => {
      t[e] = function toRef(e, t) {
        return isRef(e[t]) ? e[t] : new ObjectRefImpl(e, t)
      }(n, e)
    }))
  } else e.exposed || (e.exposed = g);
  x && e.render === NOOP && (e.render = x), null != P && (e.inheritAttrs = P), T && (e.components = T), j && (e.directives = j)
}

function callHook(e, t, n) {
  callWithAsyncErrorHandling(w(e) ? e.map((e => e.bind(t.proxy))) : e.bind(t.proxy), t, n)
}

function createWatcher(e, t, n, r) {
  const o = r.includes(".") ? createPathGetter(n, r) : () => n[r];
  if (isString$1(e)) {
    const n = t[e];
    isFunction(n) && watch(o, n)
  } else if (isFunction(e)) watch(o, e.bind(n)); else if (isObject(e)) if (w(e)) e.forEach((e => createWatcher(e, t, n, r))); else {
    const r = isFunction(e.handler) ? e.handler.bind(n) : t[e.handler];
    isFunction(r) && watch(o, r, e)
  }
}

function resolveMergedOptions(e) {
  const t = e.type, {mixins: n, extends: r} = t, {
    mixins: o,
    optionsCache: s,
    config: {optionMergeStrategies: a}
  } = e.appContext, i = s.get(t);
  let l;
  return i ? l = i : o.length || n || r ? (l = {}, o.length && o.forEach((e => mergeOptions$1(l, e, a, !0))), mergeOptions$1(l, t, a)) : l = t, s.set(t, l), l
}

function mergeOptions$1(e, t, n, r = !1) {
  const {mixins: o, extends: s} = t;
  s && mergeOptions$1(e, s, n, !0), o && o.forEach((t => mergeOptions$1(e, t, n, !0)));
  for (const a in t) if (r && "expose" === a) ; else {
    const r = je[a] || n && n[a];
    e[a] = r ? r(e[a], t[a]) : t[a]
  }
  return e
}

const je = {
  data: mergeDataFn,
  props: mergeObjectOptions,
  emits: mergeObjectOptions,
  methods: mergeObjectOptions,
  computed: mergeObjectOptions,
  beforeCreate: mergeAsArray,
  created: mergeAsArray,
  beforeMount: mergeAsArray,
  mounted: mergeAsArray,
  beforeUpdate: mergeAsArray,
  updated: mergeAsArray,
  beforeDestroy: mergeAsArray,
  destroyed: mergeAsArray,
  activated: mergeAsArray,
  deactivated: mergeAsArray,
  errorCaptured: mergeAsArray,
  serverPrefetch: mergeAsArray,
  components: mergeObjectOptions,
  directives: mergeObjectOptions,
  watch: function mergeWatchOptions(e, t) {
    if (!e) return t;
    if (!t) return e;
    const n = b(Object.create(null), e);
    for (const r in t) n[r] = mergeAsArray(e[r], t[r]);
    return n
  },
  provide: mergeDataFn,
  inject: function mergeInject(e, t) {
    return mergeObjectOptions(normalizeInject(e), normalizeInject(t))
  }
};

function mergeDataFn(e, t) {
  return t ? e ? function mergedDataFn() {
    return b(isFunction(e) ? e.call(this, this) : e, isFunction(t) ? t.call(this, this) : t)
  } : t : e
}

function normalizeInject(e) {
  if (w(e)) {
    const t = {};
    for (let n = 0; n < e.length; n++) t[e[n]] = e[n];
    return t
  }
  return e
}

function mergeAsArray(e, t) {
  return e ? [...new Set([].concat(e, t))] : t
}

function mergeObjectOptions(e, t) {
  return e ? b(b(Object.create(null), e), t) : t
}

function initProps(e, t, n, r = !1) {
  const o = {}, s = {};
  def(s, Ue, 1), e.propsDefaults = Object.create(null), setFullProps(e, t, o, s);
  for (const a in e.propsOptions[0]) a in o || (o[a] = void 0);
  n ? e.props = r ? o : function shallowReactive(e) {
    return createReactiveObject(e, !1, q, Z, ne)
  }(o) : e.type.props ? e.props = o : e.props = s, e.attrs = s
}

function setFullProps(e, t, n, r) {
  const [o, s] = e.propsOptions;
  let a, i = !1;
  if (t) for (let l in t) {
    if (k(l)) continue;
    const c = t[l];
    let u;
    o && hasOwn(o, u = S(l)) ? s && s.includes(u) ? (a || (a = {}))[u] = c : n[u] = c : isEmitListener(e.emitsOptions, l) || c !== r[l] && (r[l] = c, i = !0)
  }
  if (s) {
    const t = toRaw(n), r = a || g;
    for (let a = 0; a < s.length; a++) {
      const i = s[a];
      n[i] = resolvePropValue(o, t, i, r[i], e, !hasOwn(r, i))
    }
  }
  return i
}

function resolvePropValue(e, t, n, r, o, s) {
  const a = e[n];
  if (null != a) {
    const e = hasOwn(a, "default");
    if (e && void 0 === r) {
      const e = a.default;
      if (a.type !== Function && isFunction(e)) {
        const {propsDefaults: s} = o;
        n in s ? r = s[n] : (setCurrentInstance(o), r = s[n] = e.call(null, t), setCurrentInstance(null))
      } else r = e
    }
    a[0] && (s && !e ? r = !1 : !a[1] || "" !== r && r !== C(n) || (r = !0))
  }
  return r
}

function normalizePropsOptions(e, t, n = !1) {
  const r = t.propsCache, o = r.get(e);
  if (o) return o;
  const s = e.props, a = {}, i = [];
  let l = !1;
  if (!isFunction(e)) {
    const extendProps = e => {
      l = !0;
      const [n, r] = normalizePropsOptions(e, t, !0);
      b(a, n), r && i.push(...r)
    };
    !n && t.mixins.length && t.mixins.forEach(extendProps), e.extends && extendProps(e.extends), e.mixins && e.mixins.forEach(extendProps)
  }
  if (!s && !l) return r.set(e, v), v;
  if (w(s)) for (let u = 0; u < s.length; u++) {
    const e = S(s[u]);
    validatePropName(e) && (a[e] = g)
  } else if (s) for (const u in s) {
    const e = S(u);
    if (validatePropName(e)) {
      const t = s[u], n = a[e] = w(t) || isFunction(t) ? {type: t} : t;
      if (n) {
        const t = getTypeIndex(Boolean, n.type), r = getTypeIndex(String, n.type);
        n[0] = t > -1, n[1] = r < 0 || t < r, (t > -1 || hasOwn(n, "default")) && i.push(e)
      }
    }
  }
  const c = [a, i];
  return r.set(e, c), c
}

function validatePropName(e) {
  return "$" !== e[0]
}

function getType(e) {
  const t = e && e.toString().match(/^\s*function (\w+)/);
  return t ? t[1] : ""
}

function isSameType(e, t) {
  return getType(e) === getType(t)
}

function getTypeIndex(e, t) {
  return w(t) ? t.findIndex((t => isSameType(t, e))) : isFunction(t) && isSameType(t, e) ? 0 : -1
}

const isInternalKey = e => "_" === e[0] || "$stable" === e,
  normalizeSlotValue = e => w(e) ? e.map(normalizeVNode) : [normalizeVNode(e)], normalizeSlot$1 = (e, t, n) => {
    const r = withCtx((e => normalizeSlotValue(t(e))), n);
    return r._c = !1, r
  }, normalizeObjectSlots = (e, t, n) => {
    const r = e._ctx;
    for (const o in e) {
      if (isInternalKey(o)) continue;
      const n = e[o];
      if (isFunction(n)) t[o] = normalizeSlot$1(0, n, r); else if (null != n) {
        const e = normalizeSlotValue(n);
        t[o] = () => e
      }
    }
  }, normalizeVNodeSlots = (e, t) => {
    const n = normalizeSlotValue(t);
    e.slots.default = () => n
  };

function withDirectives(e, t) {
  if (null === be) return e;
  const n = be.proxy, r = e.dirs || (e.dirs = []);
  for (let o = 0; o < t.length; o++) {
    let [e, s, a, i = g] = t[o];
    isFunction(e) && (e = {mounted: e, updated: e}), r.push({
      dir: e,
      instance: n,
      value: s,
      oldValue: void 0,
      arg: a,
      modifiers: i
    })
  }
  return e
}

function invokeDirectiveHook(e, t, n, r) {
  const o = e.dirs, s = t && t.dirs;
  for (let a = 0; a < o.length; a++) {
    const i = o[a];
    s && (i.oldValue = s[a].value);
    let l = i.dir[r];
    l && (pauseTracking(), callWithAsyncErrorHandling(l, n, 8, [e.el, i, e, t]), resetTracking())
  }
}

function createAppContext() {
  return {
    app: null,
    config: {
      isNativeTag: NO,
      performance: !1,
      globalProperties: {},
      optionMergeStrategies: {},
      errorHandler: void 0,
      warnHandler: void 0,
      compilerOptions: {}
    },
    mixins: [],
    components: {},
    directives: {},
    provides: Object.create(null),
    optionsCache: new WeakMap,
    propsCache: new WeakMap,
    emitsCache: new WeakMap
  }
}

let Ne = 0;

function createAppAPI(e, t) {
  return function createApp2(n, r = null) {
    null == r || isObject(r) || (r = null);
    const o = createAppContext(), s = new Set;
    let a = !1;
    const i = o.app = {
      _uid: Ne++,
      _component: n,
      _props: r,
      _container: null,
      _context: o,
      _instance: null,
      version: Ze,
      get config() {
        return o.config
      },
      set config(e) {
      },
      use: (e, ...t) => (s.has(e) || (e && isFunction(e.install) ? (s.add(e), e.install(i, ...t)) : isFunction(e) && (s.add(e), e(i, ...t))), i),
      mixin: e => (o.mixins.includes(e) || o.mixins.push(e), i),
      component: (e, t) => t ? (o.components[e] = t, i) : o.components[e],
      directive: (e, t) => t ? (o.directives[e] = t, i) : o.directives[e],
      mount(s, l, c) {
        if (!a) {
          const u = De(n, r);
          return u.appContext = o, l && t ? t(u, s) : e(u, s, c), a = !0, i._container = s, s.__vue_app__ = i, u.component.proxy
        }
      },
      unmount() {
        a && (e(null, i._container), delete i._container.__vue_app__)
      },
      provide: (e, t) => (o.provides[e] = t, i)
    };
    return i
  }
}

const Ie = {scheduler: queueJob, allowRecurse: !0}, Me = function queueEffectWithSuspense(e, t) {
  t && t.pendingBranch ? w(e) ? t.effects.push(...e) : t.effects.push(e) : function queuePostFlushCb(e) {
    queueCb(e, he, de, me)
  }(e)
}, setRef = (e, t, n, r, o = !1) => {
  if (w(e)) return void e.forEach(((e, s) => setRef(e, t && (w(t) ? t[s] : t), n, r, o)));
  if (isAsyncWrapper(r) && !o) return;
  const s = 4 & r.shapeFlag ? r.component.exposed || r.component.proxy : r.el, a = o ? null : s, {i, r: l} = e,
    c = t && t.r, u = i.refs === g ? i.refs = {} : i.refs, f = i.setupState;
  if (null != c && c !== l && (isString$1(c) ? (u[c] = null, hasOwn(f, c) && (f[c] = null)) : isRef(c) && (c.value = null)), isString$1(l)) {
    const doSet = () => {
      u[l] = a, hasOwn(f, l) && (f[l] = a)
    };
    a ? (doSet.id = -1, Me(doSet, n)) : doSet()
  } else if (isRef(l)) {
    const doSet = () => {
      l.value = a
    };
    a ? (doSet.id = -1, Me(doSet, n)) : doSet()
  } else isFunction(l) && callWithErrorHandling(l, i, 12, [a, u])
};

function createRenderer(e) {
  return function baseCreateRenderer(e, t) {
    const {
        insert: n,
        remove: r,
        patchProp: o,
        forcePatchProp: s,
        createElement: a,
        createText: i,
        createComment: l,
        setText: c,
        setElementText: u,
        parentNode: f,
        nextSibling: p,
        setScopeId: d = NOOP,
        cloneNode: m,
        insertStaticContent: y
      } = e, patch = (e, t, n, r = null, o = null, s = null, a = !1, i = null, l = !1) => {
        e && !isSameVNodeType(e, t) && (r = getNextHostNode(e), unmount(e, o, s, !0), e = null), -2 === t.patchFlag && (l = !1, t.dynamicChildren = null);
        const {type: c, ref: u, shapeFlag: f} = t;
        switch (c) {
          case Ve:
            processText(e, t, n, r);
            break;
          case He:
            processCommentNode(e, t, n, r);
            break;
          case Be:
            null == e && mountStaticNode(t, n, r, a);
            break;
          case Le:
            processFragment(e, t, n, r, o, s, a, i, l);
            break;
          default:
            1 & f ? processElement(e, t, n, r, o, s, a, i, l) : 6 & f ? processComponent(e, t, n, r, o, s, a, i, l) : (64 & f || 128 & f) && c.process(e, t, n, r, o, s, a, i, l, R)
        }
        null != u && o && setRef(u, e && e.ref, s, t || e, !t)
      }, processText = (e, t, r, o) => {
        if (null == e) n(t.el = i(t.children), r, o); else {
          const n = t.el = e.el;
          t.children !== e.children && c(n, t.children)
        }
      }, processCommentNode = (e, t, r, o) => {
        null == e ? n(t.el = l(t.children || ""), r, o) : t.el = e.el
      }, mountStaticNode = (e, t, n, r) => {
        [e.el, e.anchor] = y(e.children, t, n, r, e.el && [e.el, e.anchor])
      }, moveStaticNode = ({el: e, anchor: t}, r, o) => {
        let s;
        for (; e && e !== t;) s = p(e), n(e, r, o), e = s;
        n(t, r, o)
      }, removeStaticNode = ({el: e, anchor: t}) => {
        let n;
        for (; e && e !== t;) n = p(e), r(e), e = n;
        r(t)
      }, processElement = (e, t, n, r, o, s, a, i, l) => {
        a = a || "svg" === t.type, null == e ? mountElement(t, n, r, o, s, a, i, l) : patchElement(e, t, o, s, a, i, l)
      }, mountElement = (e, t, r, s, i, l, c, f) => {
        let p, d;
        const {type: g, props: v, shapeFlag: y, transition: b, patchFlag: R, dirs: w} = e;
        if (e.el && void 0 !== m && -1 === R) p = e.el = m(e.el); else {
          if (p = e.el = a(e.type, l, v && v.is, v), 8 & y ? u(p, e.children) : 16 & y && mountChildren(e.children, p, null, s, i, l && "foreignObject" !== g, c, f || !!e.dynamicChildren), w && invokeDirectiveHook(e, null, s, "created"), v) {
            for (const t in v) k(t) || o(p, t, null, v[t], l, e.children, s, i, unmountChildren);
            (d = v.onVnodeBeforeMount) && invokeVNodeHook(d, s, e)
          }
          setScopeId(p, e, e.scopeId, c, s)
        }
        w && invokeDirectiveHook(e, null, s, "beforeMount");
        const _ = (!i || i && !i.pendingBranch) && b && !b.persisted;
        _ && b.beforeEnter(p), n(p, t, r), ((d = v && v.onVnodeMounted) || _ || w) && Me((() => {
          d && invokeVNodeHook(d, s, e), _ && b.enter(p), w && invokeDirectiveHook(e, null, s, "mounted")
        }), i)
      }, setScopeId = (e, t, n, r, o) => {
        if (n && d(e, n), r) for (let s = 0; s < r.length; s++) d(e, r[s]);
        if (o) {
          if (t === o.subTree) {
            const t = o.vnode;
            setScopeId(e, t, t.scopeId, t.slotScopeIds, o.parent)
          }
        }
      }, mountChildren = (e, t, n, r, o, s, a, i, l = 0) => {
        for (let c = l; c < e.length; c++) {
          const l = e[c] = i ? cloneIfMounted(e[c]) : normalizeVNode(e[c]);
          patch(null, l, t, n, r, o, s, a, i)
        }
      }, patchElement = (e, t, n, r, a, i, l) => {
        const c = t.el = e.el;
        let {patchFlag: f, dynamicChildren: p, dirs: d} = t;
        f |= 16 & e.patchFlag;
        const m = e.props || g, v = t.props || g;
        let y;
        if ((y = v.onVnodeBeforeUpdate) && invokeVNodeHook(y, n, t, e), d && invokeDirectiveHook(t, e, n, "beforeUpdate"), f > 0) {
          if (16 & f) patchProps(c, t, m, v, n, r, a); else if (2 & f && m.class !== v.class && o(c, "class", null, v.class, a), 4 & f && o(c, "style", m.style, v.style, a), 8 & f) {
            const i = t.dynamicProps;
            for (let t = 0; t < i.length; t++) {
              const l = i[t], u = m[l], f = v[l];
              (f !== u || s && s(c, l)) && o(c, l, u, f, a, e.children, n, r, unmountChildren)
            }
          }
          1 & f && e.children !== t.children && u(c, t.children)
        } else l || null != p || patchProps(c, t, m, v, n, r, a);
        const b = a && "foreignObject" !== t.type;
        p ? patchBlockChildren(e.dynamicChildren, p, c, n, r, b, i) : l || patchChildren(e, t, c, null, n, r, b, i, !1), ((y = v.onVnodeUpdated) || d) && Me((() => {
          y && invokeVNodeHook(y, n, t, e), d && invokeDirectiveHook(t, e, n, "updated")
        }), r)
      }, patchBlockChildren = (e, t, n, r, o, s, a) => {
        for (let i = 0; i < t.length; i++) {
          const l = e[i], c = t[i],
            u = l.el && (l.type === Le || !isSameVNodeType(l, c) || 6 & l.shapeFlag || 64 & l.shapeFlag) ? f(l.el) : n;
          patch(l, c, u, null, r, o, s, a, !0)
        }
      }, patchProps = (e, t, n, r, a, i, l) => {
        if (n !== r) {
          for (const c in r) {
            if (k(c)) continue;
            const u = r[c], f = n[c];
            (u !== f || s && s(e, c)) && o(e, c, f, u, l, t.children, a, i, unmountChildren)
          }
          if (n !== g) for (const s in n) k(s) || s in r || o(e, s, n[s], null, l, t.children, a, i, unmountChildren)
        }
      }, processFragment = (e, t, r, o, s, a, l, c, u) => {
        const f = t.el = e ? e.el : i(""), p = t.anchor = e ? e.anchor : i("");
        let {patchFlag: d, dynamicChildren: m, slotScopeIds: g} = t;
        m && (u = !0), g && (c = c ? c.concat(g) : g), null == e ? (n(f, r, o), n(p, r, o), mountChildren(t.children, r, p, s, a, l, c, u)) : d > 0 && 64 & d && m && e.dynamicChildren ? (patchBlockChildren(e.dynamicChildren, m, r, s, a, l, c), (null != t.key || s && t === s.subTree) && traverseStaticChildren(e, t, !0)) : patchChildren(e, t, r, p, s, a, l, c, u)
      }, processComponent = (e, t, n, r, o, s, a, i, l) => {
        t.slotScopeIds = i, null == e ? 512 & t.shapeFlag ? o.ctx.activate(t, n, r, a, l) : mountComponent(t, n, r, o, s, a, l) : updateComponent(e, t, l)
      }, mountComponent = (e, t, n, r, o, s, a) => {
        const i = e.component = function createComponentInstance(e, t, n) {
          const r = e.type, o = (t ? t.appContext : e.appContext) || Qe, s = {
            uid: Je++,
            vnode: e,
            type: r,
            parent: t,
            appContext: o,
            root: null,
            next: null,
            subTree: null,
            update: null,
            render: null,
            proxy: null,
            exposed: null,
            withProxy: null,
            effects: null,
            provides: t ? t.provides : Object.create(o.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: normalizePropsOptions(r, o),
            emitsOptions: normalizeEmitsOptions(r, o),
            emit: null,
            emitted: null,
            propsDefaults: g,
            inheritAttrs: r.inheritAttrs,
            ctx: g,
            data: g,
            props: g,
            attrs: g,
            slots: g,
            refs: g,
            setupState: g,
            setupContext: null,
            suspense: n,
            suspenseId: n ? n.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
          };
          return s.ctx = {_: s}, s.root = t ? t.root : s, s.emit = emit.bind(null, s), s
        }(e, r, o);
        if (isKeepAlive(e) && (i.ctx.renderer = R), function setupComponent(e, t = !1) {
          Xe = t;
          const {props: n, children: r} = e.vnode, o = isStatefulComponent(e);
          initProps(e, n, o, t), ((e, t) => {
            if (32 & e.vnode.shapeFlag) {
              const n = t._;
              n ? (e.slots = toRaw(t), def(t, "_", n)) : normalizeObjectSlots(t, e.slots = {})
            } else e.slots = {}, t && normalizeVNodeSlots(e, t);
            def(e.slots, Ue, 1)
          })(e, r);
          const s = o ? function setupStatefulComponent(e, t) {
            const n = e.type;
            e.accessCache = Object.create(null), e.proxy = function markRaw(e) {
              return def(e, "__v_skip", !0), e
            }(new Proxy(e.ctx, qe));
            const {setup: r} = n;
            if (r) {
              const n = e.setupContext = r.length > 1 ? function createSetupContext(e) {
                const expose = t => {
                  e.exposed = proxyRefs(t)
                };
                return {attrs: e.attrs, slots: e.slots, emit: e.emit, expose}
              }(e) : null;
              Ye = e, pauseTracking();
              const o = callWithErrorHandling(r, e, 0, [e.props, n]);
              if (resetTracking(), Ye = null, isPromise(o)) {
                if (t) return o.then((t => {
                  handleSetupResult(e, t)
                })).catch((t => {
                  handleError(t, e, 0)
                }));
                e.asyncDep = o
              } else handleSetupResult(e, o)
            } else finishComponentSetup(e)
          }(e, t) : void 0;
          return Xe = !1, s
        }(i), i.asyncDep) {
          if (o && o.registerDep(i, setupRenderEffect), !e.el) {
            const e = i.subTree = De(He);
            processCommentNode(null, e, t, n)
          }
        } else setupRenderEffect(i, e, t, n, o, s, a)
      }, updateComponent = (e, t, n) => {
        const r = t.component = e.component;
        if (function shouldUpdateComponent(e, t, n) {
          const {props: r, children: o, component: s} = e, {props: a, children: i, patchFlag: l} = t, c = s.emitsOptions;
          if (t.dirs || t.transition) return !0;
          if (!(n && l >= 0)) return !(!o && !i || i && i.$stable) || r !== a && (r ? !a || hasPropsChanged(r, a, c) : !!a);
          if (1024 & l) return !0;
          if (16 & l) return r ? hasPropsChanged(r, a, c) : !!a;
          if (8 & l) {
            const e = t.dynamicProps;
            for (let t = 0; t < e.length; t++) {
              const n = e[t];
              if (a[n] !== r[n] && !isEmitListener(c, n)) return !0
            }
          }
          return !1
        }(e, t, n)) {
          if (r.asyncDep && !r.asyncResolved) return void updateComponentPreRender(r, t, n);
          r.next = t, function invalidateJob(e) {
            const t = le.indexOf(e);
            t > ce && le.splice(t, 1)
          }(r.update), r.update()
        } else t.component = e.component, t.el = e.el, r.vnode = t
      }, setupRenderEffect = (e, t, n, r, o, s, a) => {
        e.update = effect((function componentEffect() {
          if (e.isMounted) {
            let t, {next: n, bu: r, u: i, parent: l, vnode: c} = e, u = n;
            n ? (n.el = c.el, updateComponentPreRender(e, n, a)) : n = c, r && invokeArrayFns(r), (t = n.props && n.props.onVnodeBeforeUpdate) && invokeVNodeHook(t, l, n, c);
            const p = renderComponentRoot(e), d = e.subTree;
            e.subTree = p, patch(d, p, f(d.el), getNextHostNode(d), e, o, s), n.el = p.el, null === u && function updateHOCHostEl({
                                                                                                                                    vnode: e,
                                                                                                                                    parent: t
                                                                                                                                  }, n) {
              for (; t && t.subTree === e;) (e = t.vnode).el = n, t = t.parent
            }(e, p.el), i && Me(i, o), (t = n.props && n.props.onVnodeUpdated) && Me((() => invokeVNodeHook(t, l, n, c)), o)
          } else {
            let a;
            const {el: i, props: l} = t, {bm: c, m: u, parent: f} = e;
            if (c && invokeArrayFns(c), (a = l && l.onVnodeBeforeMount) && invokeVNodeHook(a, f, t), i && _) {
              const hydrateSubTree = () => {
                e.subTree = renderComponentRoot(e), _(i, e.subTree, e, o, null)
              };
              isAsyncWrapper(t) ? t.type.__asyncLoader().then((() => !e.isUnmounted && hydrateSubTree())) : hydrateSubTree()
            } else {
              const a = e.subTree = renderComponentRoot(e);
              patch(null, a, n, r, e, o, s), t.el = a.el
            }
            if (u && Me(u, o), a = l && l.onVnodeMounted) {
              const e = t;
              Me((() => invokeVNodeHook(a, f, e)), o)
            }
            256 & t.shapeFlag && e.a && Me(e.a, o), e.isMounted = !0, t = n = r = null
          }
        }), Ie)
      }, updateComponentPreRender = (e, t, n) => {
        t.component = e;
        const r = e.vnode.props;
        e.vnode = t, e.next = null, function updateProps(e, t, n, r) {
          const {props: o, attrs: s, vnode: {patchFlag: a}} = e, i = toRaw(o), [l] = e.propsOptions;
          let c = !1;
          if (!(r || a > 0) || 16 & a) {
            let r;
            setFullProps(e, t, o, s) && (c = !0);
            for (const s in i) t && (hasOwn(t, s) || (r = C(s)) !== s && hasOwn(t, r)) || (l ? !n || void 0 === n[s] && void 0 === n[r] || (o[s] = resolvePropValue(l, i, s, void 0, e, !0)) : delete o[s]);
            if (s !== i) for (const e in s) t && hasOwn(t, e) || (delete s[e], c = !0)
          } else if (8 & a) {
            const n = e.vnode.dynamicProps;
            for (let r = 0; r < n.length; r++) {
              let a = n[r];
              const u = t[a];
              if (l) if (hasOwn(s, a)) u !== s[a] && (s[a] = u, c = !0); else {
                const t = S(a);
                o[t] = resolvePropValue(l, i, t, u, e, !1)
              } else u !== s[a] && (s[a] = u, c = !0)
            }
          }
          c && trigger(e, "set", "$attrs")
        }(e, t.props, r, n), ((e, t, n) => {
          const {vnode: r, slots: o} = e;
          let s = !0, a = g;
          if (32 & r.shapeFlag) {
            const e = t._;
            e ? n && 1 === e ? s = !1 : (b(o, t), n || 1 !== e || delete o._) : (s = !t.$stable, normalizeObjectSlots(t, o)), a = t
          } else t && (normalizeVNodeSlots(e, t), a = {default: 1});
          if (s) for (const i in o) isInternalKey(i) || i in a || delete o[i]
        })(e, t.children, n), pauseTracking(), flushPreFlushCbs(void 0, e.update), resetTracking()
      }, patchChildren = (e, t, n, r, o, s, a, i, l = !1) => {
        const c = e && e.children, f = e ? e.shapeFlag : 0, p = t.children, {patchFlag: d, shapeFlag: m} = t;
        if (d > 0) {
          if (128 & d) return void patchKeyedChildren(c, p, n, r, o, s, a, i, l);
          if (256 & d) return void patchUnkeyedChildren(c, p, n, r, o, s, a, i, l)
        }
        8 & m ? (16 & f && unmountChildren(c, o, s), p !== c && u(n, p)) : 16 & f ? 16 & m ? patchKeyedChildren(c, p, n, r, o, s, a, i, l) : unmountChildren(c, o, s, !0) : (8 & f && u(n, ""), 16 & m && mountChildren(p, n, r, o, s, a, i, l))
      }, patchUnkeyedChildren = (e, t, n, r, o, s, a, i, l) => {
        t = t || v;
        const c = (e = e || v).length, u = t.length, f = Math.min(c, u);
        let p;
        for (p = 0; p < f; p++) {
          const r = t[p] = l ? cloneIfMounted(t[p]) : normalizeVNode(t[p]);
          patch(e[p], r, n, null, o, s, a, i, l)
        }
        c > u ? unmountChildren(e, o, s, !0, !1, f) : mountChildren(t, n, r, o, s, a, i, l, f)
      }, patchKeyedChildren = (e, t, n, r, o, s, a, i, l) => {
        let c = 0;
        const u = t.length;
        let f = e.length - 1, p = u - 1;
        for (; c <= f && c <= p;) {
          const r = e[c], u = t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c]);
          if (!isSameVNodeType(r, u)) break;
          patch(r, u, n, null, o, s, a, i, l), c++
        }
        for (; c <= f && c <= p;) {
          const r = e[f], c = t[p] = l ? cloneIfMounted(t[p]) : normalizeVNode(t[p]);
          if (!isSameVNodeType(r, c)) break;
          patch(r, c, n, null, o, s, a, i, l), f--, p--
        }
        if (c > f) {
          if (c <= p) {
            const e = p + 1, f = e < u ? t[e].el : r;
            for (; c <= p;) patch(null, t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c]), n, f, o, s, a, i, l), c++
          }
        } else if (c > p) for (; c <= f;) unmount(e[c], o, s, !0), c++; else {
          const d = c, m = c, g = new Map;
          for (c = m; c <= p; c++) {
            const e = t[c] = l ? cloneIfMounted(t[c]) : normalizeVNode(t[c]);
            null != e.key && g.set(e.key, c)
          }
          let y, b = 0;
          const R = p - m + 1;
          let w = !1, _ = 0;
          const k = new Array(R);
          for (c = 0; c < R; c++) k[c] = 0;
          for (c = d; c <= f; c++) {
            const r = e[c];
            if (b >= R) {
              unmount(r, o, s, !0);
              continue
            }
            let u;
            if (null != r.key) u = g.get(r.key); else for (y = m; y <= p; y++) if (0 === k[y - m] && isSameVNodeType(r, t[y])) {
              u = y;
              break
            }
            void 0 === u ? unmount(r, o, s, !0) : (k[u - m] = c + 1, u >= _ ? _ = u : w = !0, patch(r, t[u], n, null, o, s, a, i, l), b++)
          }
          const x = w ? function getSequence(e) {
            const t = e.slice(), n = [0];
            let r, o, s, a, i;
            const l = e.length;
            for (r = 0; r < l; r++) {
              const l = e[r];
              if (0 !== l) {
                if (o = n[n.length - 1], e[o] < l) {
                  t[r] = o, n.push(r);
                  continue
                }
                for (s = 0, a = n.length - 1; s < a;) i = (s + a) / 2 | 0, e[n[i]] < l ? s = i + 1 : a = i;
                l < e[n[s]] && (s > 0 && (t[r] = n[s - 1]), n[s] = r)
              }
            }
            s = n.length, a = n[s - 1];
            for (; s-- > 0;) n[s] = a, a = t[a];
            return n
          }(k) : v;
          for (y = x.length - 1, c = R - 1; c >= 0; c--) {
            const e = m + c, f = t[e], p = e + 1 < u ? t[e + 1].el : r;
            0 === k[c] ? patch(null, f, n, p, o, s, a, i, l) : w && (y < 0 || c !== x[y] ? move(f, n, p, 2) : y--)
          }
        }
      }, move = (e, t, r, o, s = null) => {
        const {el: a, type: i, transition: l, children: c, shapeFlag: u} = e;
        if (6 & u) return void move(e.component.subTree, t, r, o);
        if (128 & u) return void e.suspense.move(t, r, o);
        if (64 & u) return void i.move(e, t, r, R);
        if (i === Le) {
          n(a, t, r);
          for (let e = 0; e < c.length; e++) move(c[e], t, r, o);
          return void n(e.anchor, t, r)
        }
        if (i === Be) return void moveStaticNode(e, t, r);
        if (2 !== o && 1 & u && l) if (0 === o) l.beforeEnter(a), n(a, t, r), Me((() => l.enter(a)), s); else {
          const {leave: e, delayLeave: o, afterLeave: s} = l, remove3 = () => n(a, t, r), performLeave = () => {
            e(a, (() => {
              remove3(), s && s()
            }))
          };
          o ? o(a, remove3, performLeave) : performLeave()
        } else n(a, t, r)
      }, unmount = (e, t, n, r = !1, o = !1) => {
        const {type: s, props: a, ref: i, children: l, dynamicChildren: c, shapeFlag: u, patchFlag: f, dirs: p} = e;
        if (null != i && setRef(i, null, n, e, !0), 256 & u) return void t.ctx.deactivate(e);
        const d = 1 & u && p;
        let m;
        if ((m = a && a.onVnodeBeforeUnmount) && invokeVNodeHook(m, t, e), 6 & u) unmountComponent(e.component, n, r); else {
          if (128 & u) return void e.suspense.unmount(n, r);
          d && invokeDirectiveHook(e, null, t, "beforeUnmount"), 64 & u ? e.type.remove(e, t, n, o, R, r) : c && (s !== Le || f > 0 && 64 & f) ? unmountChildren(c, t, n, !1, !0) : (s === Le && (128 & f || 256 & f) || !o && 16 & u) && unmountChildren(l, t, n), r && remove2(e)
        }
        ((m = a && a.onVnodeUnmounted) || d) && Me((() => {
          m && invokeVNodeHook(m, t, e), d && invokeDirectiveHook(e, null, t, "unmounted")
        }), n)
      }, remove2 = e => {
        const {type: t, el: n, anchor: o, transition: s} = e;
        if (t === Le) return void removeFragment(n, o);
        if (t === Be) return void removeStaticNode(e);
        const performRemove = () => {
          r(n), s && !s.persisted && s.afterLeave && s.afterLeave()
        };
        if (1 & e.shapeFlag && s && !s.persisted) {
          const {leave: t, delayLeave: r} = s, performLeave = () => t(n, performRemove);
          r ? r(e.el, performRemove, performLeave) : performLeave()
        } else performRemove()
      }, removeFragment = (e, t) => {
        let n;
        for (; e !== t;) n = p(e), r(e), e = n;
        r(t)
      }, unmountComponent = (e, t, n) => {
        const {bum: r, effects: o, update: s, subTree: a, um: i} = e;
        if (r && invokeArrayFns(r), o) for (let l = 0; l < o.length; l++) stop(o[l]);
        s && (stop(s), unmount(a, e, t, n)), i && Me(i, t), Me((() => {
          e.isUnmounted = !0
        }), t), t && t.pendingBranch && !t.isUnmounted && e.asyncDep && !e.asyncResolved && e.suspenseId === t.pendingId && (t.deps--, 0 === t.deps && t.resolve())
      }, unmountChildren = (e, t, n, r = !1, o = !1, s = 0) => {
        for (let a = s; a < e.length; a++) unmount(e[a], t, n, r, o)
      },
      getNextHostNode = e => 6 & e.shapeFlag ? getNextHostNode(e.component.subTree) : 128 & e.shapeFlag ? e.suspense.next() : p(e.anchor || e.el),
      render = (e, t, n) => {
        null == e ? t._vnode && unmount(t._vnode, null, null, !0) : patch(t._vnode || null, e, t, null, null, null, n), flushPostFlushCbs(), t._vnode = e
      }, R = {
        p: patch,
        um: unmount,
        m: move,
        r: remove2,
        mt: mountComponent,
        mc: mountChildren,
        pc: patchChildren,
        pbc: patchBlockChildren,
        n: getNextHostNode,
        o: e
      };
    let w, _;
    t && ([w, _] = t(R));
    return {render, hydrate: w, createApp: createAppAPI(render, w)}
  }(e)
}

function invokeVNodeHook(e, t, n, r = null) {
  callWithAsyncErrorHandling(e, t, 7, [n, r])
}

function traverseStaticChildren(e, t, n = !1) {
  const r = e.children, o = t.children;
  if (w(r) && w(o)) for (let s = 0; s < r.length; s++) {
    const e = r[s];
    let t = o[s];
    1 & t.shapeFlag && !t.dynamicChildren && ((t.patchFlag <= 0 || 32 === t.patchFlag) && (t = o[s] = cloneIfMounted(o[s]), t.el = e.el), n || traverseStaticChildren(e, t))
  }
}

function resolveComponent(e, t) {
  return resolveAsset("components", e, !0, t) || e
}

const Fe = Symbol();

function resolveAsset(e, t, n = !0, r = !1) {
  const o = be || Ye;
  if (o) {
    const n = o.type;
    if ("components" === e) {
      const e = getComponentName(n);
      if (e && (e === t || e === S(t) || e === A(S(t)))) return n
    }
    const s = resolve(o[e] || n[e], t) || resolve(o.appContext[e], t);
    return !s && r ? n : s
  }
}

function resolve(e, t) {
  return e && (e[t] || e[S(t)] || e[A(S(t))])
}

const Le = Symbol(void 0), Ve = Symbol(void 0), He = Symbol(void 0), Be = Symbol(void 0), ze = [];
let $e = null;

function openBlock(e = !1) {
  ze.push($e = e ? null : [])
}

let We = 1;

function setBlockTracking(e) {
  We += e
}

function createBlock(e, t, n, r, o) {
  const s = De(e, t, n, r, o, !0);
  return s.dynamicChildren = We > 0 ? $e || v : null, function closeBlock() {
    ze.pop(), $e = ze[ze.length - 1] || null
  }(), We > 0 && $e && $e.push(s), s
}

function isVNode(e) {
  return !!e && !0 === e.__v_isVNode
}

function isSameVNodeType(e, t) {
  return e.type === t.type && e.key === t.key
}

const Ue = "__vInternal", normalizeKey = ({key: e}) => null != e ? e : null,
  normalizeRef = ({ref: e}) => null != e ? isString$1(e) || isRef(e) || isFunction(e) ? {i: be, r: e} : e : null,
  De = function _createVNode(e, t = null, n = null, r = 0, o = null, s = !1) {
    e && e !== Fe || (e = He);
    if (isVNode(e)) {
      const r = cloneVNode(e, t, !0);
      return n && normalizeChildren(r, n), r
    }
    (function isClassComponent(e) {
      return isFunction(e) && "__vccOpts" in e
    })(e) && (e = e.__vccOpts);
    if (t) {
      (isProxy(t) || Ue in t) && (t = b({}, t));
      let {class: e, style: n} = t;
      e && !isString$1(e) && (t.class = normalizeClass(e)), isObject(n) && (isProxy(n) && !w(n) && (n = b({}, n)), t.style = normalizeStyle(n))
    }
    const a = isString$1(e) ? 1 : (e => e.__isSuspense)(e) ? 128 : (e => e.__isTeleport)(e) ? 64 : isObject(e) ? 4 : isFunction(e) ? 2 : 0,
      i = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && normalizeKey(t),
        ref: t && normalizeRef(t),
        scopeId: Re,
        slotScopeIds: null,
        children: null,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: a,
        patchFlag: r,
        dynamicProps: o,
        dynamicChildren: null,
        appContext: null
      };
    normalizeChildren(i, n), 128 & a && e.normalize(i);
    We > 0 && !s && $e && (r > 0 || 6 & a) && 32 !== r && $e.push(i);
    return i
  };

function cloneVNode(e, t, n = !1) {
  const {props: r, ref: o, patchFlag: s, children: a} = e, i = t ? function mergeProps(...e) {
    const t = b({}, e[0]);
    for (let n = 1; n < e.length; n++) {
      const r = e[n];
      for (const e in r) if ("class" === e) t.class !== r.class && (t.class = normalizeClass([t.class, r.class])); else if ("style" === e) t.style = normalizeStyle([t.style, r.style]); else if (isOn(e)) {
        const n = t[e], o = r[e];
        n !== o && (t[e] = n ? [].concat(n, o) : o)
      } else "" !== e && (t[e] = r[e])
    }
    return t
  }(r || {}, t) : r;
  return {
    __v_isVNode: !0,
    __v_skip: !0,
    type: e.type,
    props: i,
    key: i && normalizeKey(i),
    ref: t && t.ref ? n && o ? w(o) ? o.concat(normalizeRef(t)) : [o, normalizeRef(t)] : normalizeRef(t) : o,
    scopeId: e.scopeId,
    slotScopeIds: e.slotScopeIds,
    children: a,
    target: e.target,
    targetAnchor: e.targetAnchor,
    staticCount: e.staticCount,
    shapeFlag: e.shapeFlag,
    patchFlag: t && e.type !== Le ? -1 === s ? 16 : 16 | s : s,
    dynamicProps: e.dynamicProps,
    dynamicChildren: e.dynamicChildren,
    appContext: e.appContext,
    dirs: e.dirs,
    transition: e.transition,
    component: e.component,
    suspense: e.suspense,
    ssContent: e.ssContent && cloneVNode(e.ssContent),
    ssFallback: e.ssFallback && cloneVNode(e.ssFallback),
    el: e.el,
    anchor: e.anchor
  }
}

function createTextVNode(e = " ", t = 0) {
  return De(Ve, null, e, t)
}

function createCommentVNode(e = "", t = !1) {
  return t ? (openBlock(), createBlock(He, null, e)) : De(He, null, e)
}

function normalizeVNode(e) {
  return null == e || "boolean" == typeof e ? De(He) : w(e) ? De(Le, null, e.slice()) : "object" == typeof e ? cloneIfMounted(e) : De(Ve, null, String(e))
}

function cloneIfMounted(e) {
  return null === e.el ? e : cloneVNode(e)
}

function normalizeChildren(e, t) {
  let n = 0;
  const {shapeFlag: r} = e;
  if (null == t) t = null; else if (w(t)) n = 16; else if ("object" == typeof t) {
    if (1 & r || 64 & r) {
      const n = t.default;
      return void (n && (n._c && (n._d = !1), normalizeChildren(e, n()), n._c && (n._d = !0)))
    }
    {
      n = 32;
      const r = t._;
      r || Ue in t ? 3 === r && be && (1 === be.slots._ ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) : t._ctx = be
    }
  } else isFunction(t) ? (t = {
    default: t,
    _ctx: be
  }, n = 32) : (t = String(t), 64 & r ? (n = 16, t = [createTextVNode(t)]) : n = 8);
  e.children = t, e.shapeFlag |= n
}

function renderList(e, t) {
  let n;
  if (w(e) || isString$1(e)) {
    n = new Array(e.length);
    for (let r = 0, o = e.length; r < o; r++) n[r] = t(e[r], r)
  } else if ("number" == typeof e) {
    n = new Array(e);
    for (let r = 0; r < e; r++) n[r] = t(r + 1, r)
  } else if (isObject(e)) if (e[Symbol.iterator]) n = Array.from(e, t); else {
    const r = Object.keys(e);
    n = new Array(r.length);
    for (let o = 0, s = r.length; o < s; o++) {
      const s = r[o];
      n[o] = t(e[s], s, o)
    }
  } else n = [];
  return n
}

const getPublicInstance = e => e ? isStatefulComponent(e) ? e.exposed ? e.exposed : e.proxy : getPublicInstance(e.parent) : null,
  Ge = b(Object.create(null), {
    $: e => e,
    $el: e => e.vnode.el,
    $data: e => e.data,
    $props: e => e.props,
    $attrs: e => e.attrs,
    $slots: e => e.slots,
    $refs: e => e.refs,
    $parent: e => getPublicInstance(e.parent),
    $root: e => getPublicInstance(e.root),
    $emit: e => e.emit,
    $options: e => resolveMergedOptions(e),
    $forceUpdate: e => () => queueJob(e.update),
    $nextTick: e => nextTick.bind(e.proxy),
    $watch: e => instanceWatch.bind(e)
  }), qe = {
    get({_: e}, t) {
      const {ctx: n, setupState: r, data: o, props: s, accessCache: a, type: i, appContext: l} = e;
      let c;
      if ("$" !== t[0]) {
        const i = a[t];
        if (void 0 !== i) switch (i) {
          case 0:
            return r[t];
          case 1:
            return o[t];
          case 3:
            return n[t];
          case 2:
            return s[t]
        } else {
          if (r !== g && hasOwn(r, t)) return a[t] = 0, r[t];
          if (o !== g && hasOwn(o, t)) return a[t] = 1, o[t];
          if ((c = e.propsOptions[0]) && hasOwn(c, t)) return a[t] = 2, s[t];
          if (n !== g && hasOwn(n, t)) return a[t] = 3, n[t];
          Te && (a[t] = 4)
        }
      }
      const u = Ge[t];
      let f, p;
      return u ? ("$attrs" === t && track(e, 0, t), u(e)) : (f = i.__cssModules) && (f = f[t]) ? f : n !== g && hasOwn(n, t) ? (a[t] = 3, n[t]) : (p = l.config.globalProperties, hasOwn(p, t) ? p[t] : void 0)
    }, set({_: e}, t, n) {
      const {data: r, setupState: o, ctx: s} = e;
      if (o !== g && hasOwn(o, t)) o[t] = n; else if (r !== g && hasOwn(r, t)) r[t] = n; else if (hasOwn(e.props, t)) return !1;
      return ("$" !== t[0] || !(t.slice(1) in e)) && (s[t] = n, !0)
    }, has({_: {data: e, setupState: t, accessCache: n, ctx: r, appContext: o, propsOptions: s}}, a) {
      let i;
      return void 0 !== n[a] || e !== g && hasOwn(e, a) || t !== g && hasOwn(t, a) || (i = s[0]) && hasOwn(i, a) || hasOwn(r, a) || hasOwn(Ge, a) || hasOwn(o.config.globalProperties, a)
    }
  }, Ke = b({}, qe, {
    get(e, t) {
      if (t !== Symbol.unscopables) return qe.get(e, t, e)
    }, has: (e, t) => "_" !== t[0] && !f(t)
  }), Qe = createAppContext();
let Je = 0;
let Ye = null;
const getCurrentInstance = () => Ye || be, setCurrentInstance = e => {
  Ye = e
};

function isStatefulComponent(e) {
  return 4 & e.vnode.shapeFlag
}

let Xe = !1;

function handleSetupResult(e, t, n) {
  isFunction(t) ? e.render = t : isObject(t) && (e.setupState = proxyRefs(t)), finishComponentSetup(e)
}

function finishComponentSetup(e, t, n) {
  const r = e.type;
  e.render || (e.render = r.render || NOOP, e.render._rc && (e.withProxy = new Proxy(e.ctx, Ke))), Ye = e, pauseTracking(), applyOptions(e), resetTracking(), Ye = null
}

function recordInstanceBoundEffect(e, t = Ye) {
  t && (t.effects || (t.effects = [])).push(e)
}

function getComponentName(e) {
  return isFunction(e) && e.displayName || e.name
}

function computed(e) {
  const t = function computed$1(e) {
    let t, n;
    return isFunction(e) ? (t = e, n = NOOP) : (t = e.get, n = e.set), new ComputedRefImpl(t, n, isFunction(e) || !e.set)
  }(e);
  return recordInstanceBoundEffect(t.effect), t
}

function h(e, t, n) {
  const r = arguments.length;
  return 2 === r ? isObject(t) && !w(t) ? isVNode(t) ? De(e, null, [t]) : De(e, t) : De(e, null, t) : (r > 3 ? n = Array.prototype.slice.call(arguments, 2) : 3 === r && isVNode(n) && (n = [n]), De(e, t, n))
}

const Ze = "3.1.2", et = "http://www.w3.org/2000/svg", tt = "undefined" != typeof document ? document : null, nt = {
  insert: (e, t, n) => {
    t.insertBefore(e, n || null)
  },
  remove: e => {
    const t = e.parentNode;
    t && t.removeChild(e)
  },
  createElement: (e, t, n, r) => {
    const o = t ? tt.createElementNS(et, e) : tt.createElement(e, n ? {is: n} : void 0);
    return "select" === e && r && null != r.multiple && o.setAttribute("multiple", r.multiple), o
  },
  createText: e => tt.createTextNode(e),
  createComment: e => tt.createComment(e),
  setText: (e, t) => {
    e.nodeValue = t
  },
  setElementText: (e, t) => {
    e.textContent = t
  },
  parentNode: e => e.parentNode,
  nextSibling: e => e.nextSibling,
  querySelector: e => tt.querySelector(e),
  setScopeId(e, t) {
    e.setAttribute(t, "")
  },
  cloneNode(e) {
    const t = e.cloneNode(!0);
    return "_value" in e && (t._value = e._value), t
  },
  insertStaticContent(e, t, n, r, o) {
    if (o) {
      let e, r, [s, a] = o;
      for (; ;) {
        let o = s.cloneNode(!0);
        if (e || (e = o), t.insertBefore(o, n), s === a) {
          r = o;
          break
        }
        s = s.nextSibling
      }
      return [e, r]
    }
    const s = n ? n.previousSibling : t.lastChild;
    if (n) {
      let o, s = !1;
      n instanceof Element ? o = n : (s = !0, o = r ? tt.createElementNS(et, "g") : tt.createElement("div"), t.insertBefore(o, n)), o.insertAdjacentHTML("beforebegin", e), s && t.removeChild(o)
    } else t.insertAdjacentHTML("beforeend", e);
    return [s ? s.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild]
  }
};
const rt = /\s*!important$/;

function setStyle(e, t, n) {
  if (w(n)) n.forEach((n => setStyle(e, t, n))); else if (t.startsWith("--")) e.setProperty(t, n); else {
    const r = function autoPrefix(e, t) {
      const n = st[t];
      if (n) return n;
      let r = S(t);
      if ("filter" !== r && r in e) return st[t] = r;
      r = A(r);
      for (let o = 0; o < ot.length; o++) {
        const n = ot[o] + r;
        if (n in e) return st[t] = n
      }
      return t
    }(e, t);
    rt.test(n) ? e.setProperty(C(r), n.replace(rt, ""), "important") : e[r] = n
  }
}

const ot = ["Webkit", "Moz", "ms"], st = {};
const at = "http://www.w3.org/1999/xlink";
let it = Date.now, lt = !1;
if ("undefined" != typeof window) {
  it() > document.createEvent("Event").timeStamp && (it = () => performance.now());
  const e = navigator.userAgent.match(/firefox\/(\d+)/i);
  lt = !!(e && Number(e[1]) <= 53)
}
let ct = 0;
const ut = Promise.resolve(), reset = () => {
  ct = 0
};

function patchEvent(e, t, n, r, o = null) {
  const s = e._vei || (e._vei = {}), a = s[t];
  if (r && a) a.value = r; else {
    const [n, i] = function parseName(e) {
      let t;
      if (ft.test(e)) {
        let n;
        for (t = {}; n = e.match(ft);) e = e.slice(0, e.length - n[0].length), t[n[0].toLowerCase()] = !0
      }
      return [C(e.slice(2)), t]
    }(t);
    if (r) {
      !function addEventListener(e, t, n, r) {
        e.addEventListener(t, n, r)
      }(e, n, s[t] = function createInvoker(e, t) {
        const invoker = e => {
          const n = e.timeStamp || it();
          (lt || n >= invoker.attached - 1) && callWithAsyncErrorHandling(function patchStopImmediatePropagation(e, t) {
            if (w(t)) {
              const n = e.stopImmediatePropagation;
              return e.stopImmediatePropagation = () => {
                n.call(e), e._stopped = !0
              }, t.map((e => t => !t._stopped && e(t)))
            }
            return t
          }(e, invoker.value), t, 5, [e])
        };
        return invoker.value = e, invoker.attached = (() => ct || (ut.then(reset), ct = it()))(), invoker
      }(r, o), i)
    } else a && (!function removeEventListener(e, t, n, r) {
      e.removeEventListener(t, n, r)
    }(e, n, a, i), s[t] = void 0)
  }
}

const ft = /(?:Once|Passive|Capture)$/;
const pt = /^on[a-z]/;
const dt = ["ctrl", "shift", "alt", "meta"], ht = {
  stop: e => e.stopPropagation(),
  prevent: e => e.preventDefault(),
  self: e => e.target !== e.currentTarget,
  ctrl: e => !e.ctrlKey,
  shift: e => !e.shiftKey,
  alt: e => !e.altKey,
  meta: e => !e.metaKey,
  left: e => "button" in e && 0 !== e.button,
  middle: e => "button" in e && 1 !== e.button,
  right: e => "button" in e && 2 !== e.button,
  exact: (e, t) => dt.some((n => e[`${n}Key`] && !t.includes(n)))
}, withModifiers = (e, t) => (n, ...r) => {
  for (let e = 0; e < t.length; e++) {
    const r = ht[t[e]];
    if (r && r(n, t)) return
  }
  return e(n, ...r)
}, mt = {
  beforeMount(e, {value: t}, {transition: n}) {
    e._vod = "none" === e.style.display ? "" : e.style.display, n && t ? n.beforeEnter(e) : setDisplay(e, t)
  }, mounted(e, {value: t}, {transition: n}) {
    n && t && n.enter(e)
  }, updated(e, {value: t, oldValue: n}, {transition: r}) {
    !t != !n && (r ? t ? (r.beforeEnter(e), setDisplay(e, !0), r.enter(e)) : r.leave(e, (() => {
      setDisplay(e, !1)
    })) : setDisplay(e, t))
  }, beforeUnmount(e, {value: t}) {
    setDisplay(e, t)
  }
};

function setDisplay(e, t) {
  e.style.display = t ? e._vod : "none"
}

const gt = b({
  patchProp: (e, t, n, r, o = !1, s, a, i, l) => {
    switch (t) {
      case"class":
        !function patchClass(e, t, n) {
          if (null == t && (t = ""), n) e.setAttribute("class", t); else {
            const n = e._vtc;
            n && (t = (t ? [t, ...n] : [...n]).join(" ")), e.className = t
          }
        }(e, r, o);
        break;
      case"style":
        !function patchStyle(e, t, n) {
          const r = e.style;
          if (n) if (isString$1(n)) {
            if (t !== n) {
              const t = r.display;
              r.cssText = n, "_vod" in e && (r.display = t)
            }
          } else {
            for (const e in n) setStyle(r, e, n[e]);
            if (t && !isString$1(t)) for (const e in t) null == n[e] && setStyle(r, e, "")
          } else e.removeAttribute("style")
        }(e, n, r);
        break;
      default:
        isOn(t) ? isModelListener(t) || patchEvent(e, t, 0, r, a) : !function shouldSetAsProp(e, t, n, r) {
          if (r) return "innerHTML" === t || !!(t in e && pt.test(t) && isFunction(n));
          if ("spellcheck" === t || "draggable" === t) return !1;
          if ("form" === t) return !1;
          if ("list" === t && "INPUT" === e.tagName) return !1;
          if ("type" === t && "TEXTAREA" === e.tagName) return !1;
          if (pt.test(t) && isString$1(n)) return !1;
          return t in e
        }(e, t, r, o) ? ("true-value" === t ? e._trueValue = r : "false-value" === t && (e._falseValue = r), function patchAttr(e, t, n, r, o) {
          if (r && t.startsWith("xlink:")) null == n ? e.removeAttributeNS(at, t.slice(6, t.length)) : e.setAttributeNS(at, t, n); else {
            const r = p(t);
            null == n || r && !1 === n ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : n)
          }
        }(e, t, r, o)) : function patchDOMProp(e, t, n, r, o, s, a) {
          if ("innerHTML" === t || "textContent" === t) return r && a(r, o, s), void (e[t] = n ?? "");
          if ("value" === t && "PROGRESS" !== e.tagName) {
            e._value = n;
            const r = n ?? "";
            return e.value !== r && (e.value = r), void (null == n && e.removeAttribute(t))
          }
          if ("" === n || null == n) {
            const r = typeof e[t];
            if ("" === n && "boolean" === r) return void (e[t] = !0);
            if (null == n && "string" === r) return e[t] = "", void e.removeAttribute(t);
            if ("number" === r) return e[t] = 0, void e.removeAttribute(t)
          }
          try {
            e[t] = n
          } catch (i) {
          }
        }(e, t, r, s, a, i, l)
    }
  }, forcePatchProp: (e, t) => "value" === t
}, nt);
let vt;
const createApp = (...e) => {
  const t = function ensureRenderer() {
    return vt || (vt = createRenderer(gt))
  }().createApp(...e), {mount: n} = t;
  return t.mount = e => {
    const r = function normalizeContainer(e) {
      if (isString$1(e)) {
        return document.querySelector(e)
      }
      return e
    }(e);
    if (!r) return;
    const o = t._component;
    isFunction(o) || o.render || o.template || (o.template = r.innerHTML), r.innerHTML = "";
    const s = n(r, !1, r instanceof SVGElement);
    return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), s
  }, t
};
const yt = {};
yt.render = function _sfc_render(e, t) {
  const n = resolveComponent("router-view");
  return openBlock(), createBlock(n, null, {
    default: withCtx((({Component: e, route: t}) => {
      return [De("main", {
        id: t.name,
        class: "h-full bg-white"
      }, [(openBlock(), createBlock((n = e, isString$1(n) ? resolveAsset("components", n, !1) || n : n || Fe)))], 8, ["id"])];
      var n
    })), _: 1
  })
};
const bt = "function" == typeof Symbol && "symbol" == typeof Symbol.toStringTag,
  PolySymbol = e => bt ? Symbol(e) : "_vr_" + e, Rt = PolySymbol("rvlm"), wt = PolySymbol("rvd"), _t = PolySymbol("r"),
  kt = PolySymbol("rl"), xt = PolySymbol("rvl"), St = "undefined" != typeof window;
const Et = Object.assign;

function applyToParams(e, t) {
  const n = {};
  for (const r in t) {
    const o = t[r];
    n[r] = Array.isArray(o) ? o.map(e) : e(o)
  }
  return n
}

let noop$1 = () => {
};
const Ct = /\/$/;

function parseURL(e, t, n = "/") {
  let r, o = {}, s = "", a = "";
  const i = t.indexOf("?"), l = t.indexOf("#", i > -1 ? i : 0);
  return i > -1 && (r = t.slice(0, i), s = t.slice(i + 1, l > -1 ? l : t.length), o = e(s)), l > -1 && (r = r || t.slice(0, l), a = t.slice(l, t.length)), r = function resolveRelativePath(e, t) {
    if (e.startsWith("/")) return e;
    if (!e) return t;
    const n = t.split("/"), r = e.split("/");
    let o, s, a = n.length - 1;
    for (o = 0; o < r.length; o++) if (s = r[o], 1 !== a && "." !== s) {
      if (".." !== s) break;
      a--
    }
    return n.slice(0, a).join("/") + "/" + r.slice(o - (o === r.length ? 1 : 0)).join("/")
  }(null != r ? r : t, n), {fullPath: r + (s && "?") + s + a, path: r, query: o, hash: a}
}

function stripBase(e, t) {
  return t && e.toLowerCase().startsWith(t.toLowerCase()) ? e.slice(t.length) || "/" : e
}

function isSameRouteRecord(e, t) {
  return (e.aliasOf || e) === (t.aliasOf || t)
}

function isSameRouteLocationParams(e, t) {
  if (Object.keys(e).length !== Object.keys(t).length) return !1;
  for (let n in e) if (!isSameRouteLocationParamsValue(e[n], t[n])) return !1;
  return !0
}

function isSameRouteLocationParamsValue(e, t) {
  return Array.isArray(e) ? isEquivalentArray(e, t) : Array.isArray(t) ? isEquivalentArray(t, e) : e === t
}

function isEquivalentArray(e, t) {
  return Array.isArray(t) ? e.length === t.length && e.every(((e, n) => e === t[n])) : 1 === e.length && e[0] === t
}

var At, Ot, Pt, Tt;

function normalizeBase(e) {
  if (!e) if (St) {
    const t = document.querySelector("base");
    e = (e = t && t.getAttribute("href") || "/").replace(/^\w+:\/\/[^\/]+/, "")
  } else e = "/";
  return "/" !== e[0] && "#" !== e[0] && (e = "/" + e), e.replace(Ct, "")
}

(Ot = At || (At = {})).pop = "pop", Ot.push = "push", (Tt = Pt || (Pt = {})).back = "back", Tt.forward = "forward", Tt.unknown = "";
const jt = /^[^#]+#/;

function createHref(e, t) {
  return e.replace(jt, "#") + t
}

const computeScrollPosition = () => ({left: window.pageXOffset, top: window.pageYOffset});

function scrollToPosition(e) {
  let t;
  if ("el" in e) {
    let n = e.el;
    const r = "string" == typeof n && n.startsWith("#"),
      o = "string" == typeof n ? r ? document.getElementById(n.slice(1)) : document.querySelector(n) : n;
    if (!o) return;
    t = function getElementPosition(e, t) {
      const n = document.documentElement.getBoundingClientRect(), r = e.getBoundingClientRect();
      return {behavior: t.behavior, left: r.left - n.left - (t.left || 0), top: r.top - n.top - (t.top || 0)}
    }(o, e)
  } else t = e;
  "scrollBehavior" in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(null != t.left ? t.left : window.pageXOffset, null != t.top ? t.top : window.pageYOffset)
}

function getScrollKey(e, t) {
  return (history.state ? history.state.position - t : -1) + e
}

const Nt = new Map;

function createCurrentLocation(e, t) {
  const {pathname: n, search: r, hash: o} = t, s = e.indexOf("#");
  if (s > -1) {
    let t = o.includes(e.slice(s)) ? e.slice(s).length : 1, n = o.slice(t);
    return "/" !== n[0] && (n = "/" + n), stripBase(n, "")
  }
  return stripBase(n, e) + r + o
}

function buildState(e, t, n, r = !1, o = !1) {
  return {
    back: e,
    current: t,
    forward: n,
    replaced: r,
    position: window.history.length,
    scroll: o ? computeScrollPosition() : null
  }
}

function useHistoryStateNavigation(e) {
  const {history: t, location: n} = window;
  let r = {value: createCurrentLocation(e, n)}, o = {value: t.state};

  function changeLocation(r, s, a) {
    const i = e.indexOf("#"),
      l = i > -1 ? (n.host && document.querySelector("base") ? e : e.slice(i)) + r : location.protocol + "//" + location.host + e + r;
    try {
      t[a ? "replaceState" : "pushState"](s, "", l), o.value = s
    } catch (c) {
      console.error(c), n[a ? "replace" : "assign"](l)
    }
  }

  return o.value || changeLocation(r.value, {
    back: null,
    current: r.value,
    forward: null,
    position: t.length - 1,
    replaced: !0,
    scroll: null
  }, !0), {
    location: r, state: o, push: function push(e, n) {
      const s = Et({}, o.value, t.state, {forward: e, scroll: computeScrollPosition()});
      changeLocation(s.current, s, !0), changeLocation(e, Et({}, buildState(r.value, e, null), {position: s.position + 1}, n), !1), r.value = e
    }, replace: function replace(e, n) {
      changeLocation(e, Et({}, t.state, buildState(o.value.back, e, o.value.forward, !0), n, {position: o.value.position}), !0), r.value = e
    }
  }
}

function createWebHistory(e) {
  const t = useHistoryStateNavigation(e = normalizeBase(e)), n = function useHistoryListeners(e, t, n, r) {
    let o = [], s = [], a = null;
    const popStateHandler = ({state: s}) => {
      const i = createCurrentLocation(e, location), l = n.value, c = t.value;
      let u = 0;
      if (s) {
        if (n.value = i, t.value = s, a && a === l) return void (a = null);
        u = c ? s.position - c.position : 0
      } else r(i);
      o.forEach((e => {
        e(n.value, l, {delta: u, type: At.pop, direction: u ? u > 0 ? Pt.forward : Pt.back : Pt.unknown})
      }))
    };

    function beforeUnloadListener() {
      const {history: e} = window;
      e.state && e.replaceState(Et({}, e.state, {scroll: computeScrollPosition()}), "")
    }

    return window.addEventListener("popstate", popStateHandler), window.addEventListener("beforeunload", beforeUnloadListener), {
      pauseListeners: function pauseListeners() {
        a = n.value
      }, listen: function listen(e) {
        o.push(e);
        const teardown = () => {
          const t = o.indexOf(e);
          t > -1 && o.splice(t, 1)
        };
        return s.push(teardown), teardown
      }, destroy: function destroy() {
        for (const e of s) e();
        s = [], window.removeEventListener("popstate", popStateHandler), window.removeEventListener("beforeunload", beforeUnloadListener)
      }
    }
  }(e, t.state, t.location, t.replace);
  const r = Et({
    location: "", base: e, go: function go(e, t = !0) {
      t || n.pauseListeners(), history.go(e)
    }, createHref: createHref.bind(null, e)
  }, t, n);
  return Object.defineProperty(r, "location", {
    enumerable: !0,
    get: () => t.location.value
  }), Object.defineProperty(r, "state", {enumerable: !0, get: () => t.state.value}), r
}

function isRouteName(e) {
  return "string" == typeof e || "symbol" == typeof e
}

const It = {
  path: "/",
  name: void 0,
  params: {},
  query: {},
  hash: "",
  fullPath: "/",
  matched: [],
  meta: {},
  redirectedFrom: void 0
}, Mt = PolySymbol("nf");
var Ft, Lt;

function createRouterError(e, t) {
  return Et(new Error, {type: e, [Mt]: !0}, t)
}

function isNavigationFailure(e, t) {
  return e instanceof Error && Mt in e && (null == t || !!(e.type & t))
}

(Lt = Ft || (Ft = {}))[Lt.aborted = 4] = "aborted", Lt[Lt.cancelled = 8] = "cancelled", Lt[Lt.duplicated = 16] = "duplicated";
const Vt = {sensitive: !1, strict: !1, start: !0, end: !0}, Ht = /[.+*?^${}()[\]/\\]/g;

function compareScoreArray(e, t) {
  let n = 0;
  for (; n < e.length && n < t.length;) {
    const r = t[n] - e[n];
    if (r) return r;
    n++
  }
  return e.length < t.length ? 1 === e.length && 80 === e[0] ? -1 : 1 : e.length > t.length ? 1 === t.length && 80 === t[0] ? 1 : -1 : 0
}

function comparePathParserScore(e, t) {
  let n = 0;
  const r = e.score, o = t.score;
  for (; n < r.length && n < o.length;) {
    const e = compareScoreArray(r[n], o[n]);
    if (e) return e;
    n++
  }
  return o.length - r.length
}

const Bt = {type: 0, value: ""}, zt = /[a-zA-Z0-9_]/;

function createRouteRecordMatcher(e, t, n) {
  const r = function tokensToParser(e, t) {
    const n = Et({}, Vt, t);
    let r = [], o = n.start ? "^" : "";
    const s = [];
    for (const l of e) {
      const e = l.length ? [] : [90];
      n.strict && !l.length && (o += "/");
      for (let t = 0; t < l.length; t++) {
        const r = l[t];
        let a = 40 + (n.sensitive ? .25 : 0);
        if (0 === r.type) t || (o += "/"), o += r.value.replace(Ht, "\\$&"), a += 40; else if (1 === r.type) {
          const {value: e, repeatable: n, optional: c, regexp: u} = r;
          s.push({name: e, repeatable: n, optional: c});
          const f = u || "[^/]+?";
          if ("[^/]+?" !== f) {
            a += 10;
            try {
              new RegExp(`(${f})`)
            } catch (i) {
              throw new Error(`Invalid custom RegExp for param "${e}" (${f}): ` + i.message)
            }
          }
          let p = n ? `((?:${f})(?:/(?:${f}))*)` : `(${f})`;
          t || (p = c && l.length < 2 ? `(?:/${p})` : "/" + p), c && (p += "?"), o += p, a += 20, c && (a += -8), n && (a += -20), ".*" === f && (a += -50)
        }
        e.push(a)
      }
      r.push(e)
    }
    if (n.strict && n.end) {
      const e = r.length - 1;
      r[e][r[e].length - 1] += .7000000000000001
    }
    n.strict || (o += "/?"), n.end ? o += "$" : n.strict && (o += "(?:/|$)");
    const a = new RegExp(o, n.sensitive ? "" : "i");
    return {
      re: a, score: r, keys: s, parse: function parse(e) {
        const t = e.match(a), n = {};
        if (!t) return null;
        for (let r = 1; r < t.length; r++) {
          const e = t[r] || "", o = s[r - 1];
          n[o.name] = e && o.repeatable ? e.split("/") : e
        }
        return n
      }, stringify: function stringify(t) {
        let n = "", r = !1;
        for (const o of e) {
          r && n.endsWith("/") || (n += "/"), r = !1;
          for (const e of o) if (0 === e.type) n += e.value; else if (1 === e.type) {
            const {value: s, repeatable: a, optional: i} = e, l = s in t ? t[s] : "";
            if (Array.isArray(l) && !a) throw new Error(`Provided param "${s}" is an array but it is not repeatable (* or + modifiers)`);
            const c = Array.isArray(l) ? l.join("/") : l;
            if (!c) {
              if (!i) throw new Error(`Missing required param "${s}"`);
              o.length < 2 && (n.endsWith("/") ? n = n.slice(0, -1) : r = !0)
            }
            n += c
          }
        }
        return n
      }
    }
  }(function tokenizePath(e) {
    if (!e) return [[]];
    if ("/" === e) return [[Bt]];
    if (!e.startsWith("/")) throw new Error(`Invalid path "${e}"`);

    function crash(e) {
      throw new Error(`ERR (${t})/"${i}": ${e}`)
    }

    let t = 0, n = t;
    const r = [];
    let o;

    function finalizeSegment() {
      o && r.push(o), o = []
    }

    let s, a = 0, i = "", l = "";

    function consumeBuffer() {
      i && (0 === t ? o.push({
        type: 0,
        value: i
      }) : 1 === t || 2 === t || 3 === t ? (o.length > 1 && ("*" === s || "+" === s) && crash(`A repeatable param (${i}) must be alone in its segment. eg: '/:ids+.`), o.push({
        type: 1,
        value: i,
        regexp: l,
        repeatable: "*" === s || "+" === s,
        optional: "*" === s || "?" === s
      })) : crash("Invalid state to consume buffer"), i = "")
    }

    function addCharToBuffer() {
      i += s
    }

    for (; a < e.length;) if (s = e[a++], "\\" !== s || 2 === t) switch (t) {
      case 0:
        "/" === s ? (i && consumeBuffer(), finalizeSegment()) : ":" === s ? (consumeBuffer(), t = 1) : addCharToBuffer();
        break;
      case 4:
        addCharToBuffer(), t = n;
        break;
      case 1:
        "(" === s ? t = 2 : zt.test(s) ? addCharToBuffer() : (consumeBuffer(), t = 0, "*" !== s && "?" !== s && "+" !== s && a--);
        break;
      case 2:
        ")" === s ? "\\" == l[l.length - 1] ? l = l.slice(0, -1) + s : t = 3 : l += s;
        break;
      case 3:
        consumeBuffer(), t = 0, "*" !== s && "?" !== s && "+" !== s && a--, l = "";
        break;
      default:
        crash("Unknown state")
    } else n = t, t = 4;
    return 2 === t && crash(`Unfinished custom RegExp for param "${i}"`), consumeBuffer(), finalizeSegment(), r
  }(e.path), n), o = Et(r, {record: e, parent: t, children: [], alias: []});
  return t && !o.record.aliasOf == !t.record.aliasOf && t.children.push(o), o
}

function createRouterMatcher(e, t) {
  const n = [], r = new Map;

  function addRoute(e, n, r) {
    let o = !r, s = function normalizeRouteRecord(e) {
      return {
        path: e.path,
        redirect: e.redirect,
        name: e.name,
        meta: e.meta || {},
        aliasOf: void 0,
        beforeEnter: e.beforeEnter,
        props: normalizeRecordProps(e),
        children: e.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components" in e ? e.components || {} : {default: e.component}
      }
    }(e);
    s.aliasOf = r && r.record;
    const a = mergeOptions(t, e), i = [s];
    if ("alias" in e) {
      const t = "string" == typeof e.alias ? [e.alias] : e.alias;
      for (const e of t) i.push(Et({}, s, {
        components: r ? r.record.components : s.components,
        path: e,
        aliasOf: r ? r.record : s
      }))
    }
    let l, c;
    for (const t of i) {
      let {path: i} = t;
      if (n && "/" !== i[0]) {
        let e = n.record.path, r = "/" === e[e.length - 1] ? "" : "/";
        t.path = n.record.path + (i && r + i)
      }
      if (l = createRouteRecordMatcher(t, n, a), r ? r.alias.push(l) : (c = c || l, c !== l && c.alias.push(l), o && e.name && !isAliasRecord(l) && removeRoute(e.name)), "children" in s) {
        let e = s.children;
        for (let t = 0; t < e.length; t++) addRoute(e[t], l, r && r.children[t])
      }
      r = r || l, insertMatcher(l)
    }
    return c ? () => {
      removeRoute(c)
    } : noop$1
  }

  function removeRoute(e) {
    if (isRouteName(e)) {
      const t = r.get(e);
      t && (r.delete(e), n.splice(n.indexOf(t), 1), t.children.forEach(removeRoute), t.alias.forEach(removeRoute))
    } else {
      let t = n.indexOf(e);
      t > -1 && (n.splice(t, 1), e.record.name && r.delete(e.record.name), e.children.forEach(removeRoute), e.alias.forEach(removeRoute))
    }
  }

  function insertMatcher(e) {
    let t = 0;
    for (; t < n.length && comparePathParserScore(e, n[t]) >= 0;) t++;
    n.splice(t, 0, e), e.record.name && !isAliasRecord(e) && r.set(e.record.name, e)
  }

  return t = mergeOptions({strict: !1, end: !0, sensitive: !1}, t), e.forEach((e => addRoute(e))), {
    addRoute,
    resolve: function resolve2(e, t) {
      let o, s, a, i = {};
      if ("name" in e && e.name) {
        if (o = r.get(e.name), !o) throw createRouterError(1, {location: e});
        a = o.record.name, i = Et(function paramsFromLocation(e, t) {
          let n = {};
          for (let r of t) r in e && (n[r] = e[r]);
          return n
        }(t.params, o.keys.filter((e => !e.optional)).map((e => e.name))), e.params), s = o.stringify(i)
      } else if ("path" in e) s = e.path, o = n.find((e => e.re.test(s))), o && (i = o.parse(s), a = o.record.name); else {
        if (o = t.name ? r.get(t.name) : n.find((e => e.re.test(t.path))), !o) throw createRouterError(1, {
          location: e,
          currentLocation: t
        });
        a = o.record.name, i = Et({}, t.params, e.params), s = o.stringify(i)
      }
      const l = [];
      let c = o;
      for (; c;) l.unshift(c.record), c = c.parent;
      return {name: a, path: s, params: i, matched: l, meta: mergeMetaFields(l)}
    },
    removeRoute,
    getRoutes: function getRoutes() {
      return n
    },
    getRecordMatcher: function getRecordMatcher(e) {
      return r.get(e)
    }
  }
}

function normalizeRecordProps(e) {
  const t = {}, n = e.props || !1;
  if ("component" in e) t.default = n; else for (let r in e.components) t[r] = "boolean" == typeof n ? n : n[r];
  return t
}

function isAliasRecord(e) {
  for (; e;) {
    if (e.record.aliasOf) return !0;
    e = e.parent
  }
  return !1
}

function mergeMetaFields(e) {
  return e.reduce(((e, t) => Et(e, t.meta)), {})
}

function mergeOptions(e, t) {
  let n = {};
  for (let r in e) n[r] = r in t ? t[r] : e[r];
  return n
}

const $t = /#/g, Wt = /&/g, Ut = /\//g, Dt = /=/g, Gt = /\?/g, qt = /\+/g, Kt = /%5B/g, Qt = /%5D/g, Jt = /%5E/g,
  Yt = /%60/g, Xt = /%7B/g, Zt = /%7C/g, en = /%7D/g, tn = /%20/g;

function commonEncode(e) {
  return encodeURI("" + e).replace(Zt, "|").replace(Kt, "[").replace(Qt, "]")
}

function encodeQueryValue(e) {
  return commonEncode(e).replace(qt, "%2B").replace(tn, "+").replace($t, "%23").replace(Wt, "%26").replace(Yt, "`").replace(Xt, "{").replace(en, "}").replace(Jt, "^")
}

function encodeParam(e) {
  return function encodePath(e) {
    return commonEncode(e).replace($t, "%23").replace(Gt, "%3F")
  }(e).replace(Ut, "%2F")
}

function decode(e) {
  try {
    return decodeURIComponent("" + e)
  } catch (t) {
  }
  return "" + e
}

function parseQuery(e) {
  const t = {};
  if ("" === e || "?" === e) return t;
  const n = ("?" === e[0] ? e.slice(1) : e).split("&");
  for (let r = 0; r < n.length; ++r) {
    const e = n[r].replace(qt, " ");
    let o = e.indexOf("="), s = decode(o < 0 ? e : e.slice(0, o)), a = o < 0 ? null : decode(e.slice(o + 1));
    if (s in t) {
      let e = t[s];
      Array.isArray(e) || (e = t[s] = [e]), e.push(a)
    } else t[s] = a
  }
  return t
}

function stringifyQuery(e) {
  let t = "";
  for (let n in e) {
    const r = e[n];
    if (n = encodeQueryValue(n).replace(Dt, "%3D"), null == r) {
      void 0 !== r && (t += (t.length ? "&" : "") + n);
      continue
    }
    (Array.isArray(r) ? r.map((e => e && encodeQueryValue(e))) : [r && encodeQueryValue(r)]).forEach((e => {
      void 0 !== e && (t += (t.length ? "&" : "") + n, null != e && (t += "=" + e))
    }))
  }
  return t
}

function normalizeQuery(e) {
  const t = {};
  for (let n in e) {
    let r = e[n];
    void 0 !== r && (t[n] = Array.isArray(r) ? r.map((e => null == e ? null : "" + e)) : null == r ? r : "" + r)
  }
  return t
}

function useCallbacks() {
  let e = [];
  return {
    add: function add2(t) {
      return e.push(t), () => {
        const n = e.indexOf(t);
        n > -1 && e.splice(n, 1)
      }
    }, list: () => e, reset: function reset2() {
      e = []
    }
  }
}

function guardToPromiseFn(e, t, n, r, o) {
  const s = r && (r.enterCallbacks[o] = r.enterCallbacks[o] || []);
  return () => new Promise(((a, i) => {
    const next = e => {
      !1 === e ? i(createRouterError(4, {from: n, to: t})) : e instanceof Error ? i(e) : !function isRouteLocation(e) {
        return "string" == typeof e || e && "object" == typeof e
      }(e) ? (s && r.enterCallbacks[o] === s && "function" == typeof e && s.push(e), a()) : i(createRouterError(2, {
        from: t,
        to: e
      }))
    }, l = e.call(r && r.instances[o], t, n, next);
    let c = Promise.resolve(l);
    e.length < 3 && (c = c.then(next)), c.catch((e => i(e)))
  }))
}

function extractComponentsGuards(e, t, n, r) {
  const o = [];
  for (const a of e) for (const e in a.components) {
    let i = a.components[e];
    if ("beforeRouteEnter" === t || a.instances[e]) if ("object" == typeof (s = i) || "displayName" in s || "props" in s || "__vccOpts" in s) {
      const s = (i.__vccOpts || i)[t];
      s && o.push(guardToPromiseFn(s, n, r, a, e))
    } else {
      let s = i();
      o.push((() => s.then((o => {
        if (!o) return Promise.reject(new Error(`Couldn't resolve component "${e}" at "${a.path}"`));
        const s = (i = o).__esModule || bt && "Module" === i[Symbol.toStringTag] ? o.default : o;
        var i;
        a.components[e] = s;
        const l = (s.__vccOpts || s)[t];
        return l && guardToPromiseFn(l, n, r, a, e)()
      }))))
    }
  }
  var s;
  return o
}

function useLink(e) {
  const t = inject(_t), n = inject(kt), r = computed((() => t.resolve(unref(e.to)))), o = computed((() => {
      let {matched: e} = r.value, {length: t} = e;
      const o = e[t - 1];
      let s = n.matched;
      if (!o || !s.length) return -1;
      let a = s.findIndex(isSameRouteRecord.bind(null, o));
      if (a > -1) return a;
      let i = getOriginalPath(e[t - 2]);
      return t > 1 && getOriginalPath(o) === i && s[s.length - 1].path !== i ? s.findIndex(isSameRouteRecord.bind(null, e[t - 2])) : a
    })), s = computed((() => o.value > -1 && function includesParams(e, t) {
      for (let n in t) {
        let r = t[n], o = e[n];
        if ("string" == typeof r) {
          if (r !== o) return !1
        } else if (!Array.isArray(o) || o.length !== r.length || r.some(((e, t) => e !== o[t]))) return !1
      }
      return !0
    }(n.params, r.value.params))),
    a = computed((() => o.value > -1 && o.value === n.matched.length - 1 && isSameRouteLocationParams(n.params, r.value.params)));
  return {
    route: r,
    href: computed((() => r.value.href)),
    isActive: s,
    isExactActive: a,
    navigate: function navigate(n = {}) {
      return function guardEvent(e) {
        if (e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) return;
        if (e.defaultPrevented) return;
        if (void 0 !== e.button && 0 !== e.button) return;
        if (e.currentTarget && e.currentTarget.getAttribute) {
          const t = e.currentTarget.getAttribute("target");
          if (/\b_blank\b/i.test(t)) return
        }
        e.preventDefault && e.preventDefault();
        return !0
      }(n) ? t[unref(e.replace) ? "replace" : "push"](unref(e.to)).catch(noop$1) : Promise.resolve()
    }
  }
}

const nn = defineComponent({
  name: "RouterLink",
  props: {
    to: {type: [String, Object], required: !0},
    replace: Boolean,
    activeClass: String,
    exactActiveClass: String,
    custom: Boolean,
    ariaCurrentValue: {type: String, default: "page"}
  },
  useLink,
  setup(e, {slots: t}) {
    const n = reactive(useLink(e)), {options: r} = inject(_t), o = computed((() => ({
      [getLinkClass(e.activeClass, r.linkActiveClass, "router-link-active")]: n.isActive,
      [getLinkClass(e.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: n.isExactActive
    })));
    return () => {
      const r = t.default && t.default(n);
      return e.custom ? r : h("a", {
        "aria-current": n.isExactActive ? e.ariaCurrentValue : null,
        href: n.href,
        onClick: n.navigate,
        class: o.value
      }, r)
    }
  }
});

function getOriginalPath(e) {
  return e ? e.aliasOf ? e.aliasOf.path : e.path : ""
}

const getLinkClass = (e, t, n) => null != e ? e : null != t ? t : n;

function normalizeSlot(e, t) {
  if (!e) return null;
  const n = e(t);
  return 1 === n.length ? n[0] : n
}

const rn = defineComponent({
  name: "RouterView",
  inheritAttrs: !1,
  props: {name: {type: String, default: "default"}, route: Object},
  setup(e, {attrs: t, slots: n}) {
    const r = inject(xt), o = computed((() => e.route || r.value)), s = inject(wt, 0),
      a = computed((() => o.value.matched[s]));
    provide(wt, s + 1), provide(Rt, a), provide(xt, o);
    const i = ref();
    return watch((() => [i.value, a.value, e.name]), (([e, t, n], [r, o, s]) => {
      t && (t.instances[n] = e, o && o !== t && e && e === r && (t.leaveGuards.size || (t.leaveGuards = o.leaveGuards), t.updateGuards.size || (t.updateGuards = o.updateGuards))), !e || !t || o && isSameRouteRecord(t, o) && r || (t.enterCallbacks[n] || []).forEach((t => t(e)))
    }), {flush: "post"}), () => {
      const r = o.value, s = a.value, l = s && s.components[e.name], c = e.name;
      if (!l) return normalizeSlot(n.default, {Component: l, route: r});
      const u = s.props[e.name], f = u ? !0 === u ? r.params : "function" == typeof u ? u(r) : u : null,
        p = h(l, Et({}, f, t, {
          onVnodeUnmounted: e => {
            e.component.isUnmounted && (s.instances[c] = null)
          }, ref: i
        }));
      return normalizeSlot(n.default, {Component: p, route: r}) || p
    }
  }
});

function createRouter(e) {
  const t = createRouterMatcher(e.routes, e);
  let n = e.parseQuery || parseQuery, r = e.stringifyQuery || stringifyQuery, o = e.history;
  const s = useCallbacks(), a = useCallbacks(), i = useCallbacks(), l = function shallowRef(e) {
    return createRef(e, !0)
  }(It);
  let c = It;
  St && e.scrollBehavior && "scrollRestoration" in history && (history.scrollRestoration = "manual");
  const u = applyToParams.bind(null, (e => "" + e)), f = applyToParams.bind(null, encodeParam),
    p = applyToParams.bind(null, decode);

  function resolve2(e, s) {
    if (s = Et({}, s || l.value), "string" == typeof e) {
      let r = parseURL(n, e, s.path), a = t.resolve({path: r.path}, s), i = o.createHref(r.fullPath);
      return Et(r, a, {params: p(a.params), hash: decode(r.hash), redirectedFrom: void 0, href: i})
    }
    let a;
    "path" in e ? a = Et({}, e, {path: parseURL(n, e.path, s.path).path}) : (a = Et({}, e, {params: f(e.params)}), s.params = f(s.params));
    let i = t.resolve(a, s);
    const c = e.hash || "";
    i.params = u(p(i.params));
    const d = function stringifyURL(e, t) {
      let n = t.query ? e(t.query) : "";
      return t.path + (n && "?") + n + (t.hash || "")
    }(r, Et({}, e, {hash: (m = c, commonEncode(m).replace(Xt, "{").replace(en, "}").replace(Jt, "^")), path: i.path}));
    var m;
    let g = o.createHref(d);
    return Et({
      fullPath: d,
      hash: c,
      query: r === stringifyQuery ? normalizeQuery(e.query) : e.query
    }, i, {redirectedFrom: void 0, href: g})
  }

  function locationAsObject(e) {
    return "string" == typeof e ? parseURL(n, e, l.value.path) : Et({}, e)
  }

  function checkCanceledNavigation(e, t) {
    if (c !== e) return createRouterError(8, {from: t, to: e})
  }

  function push(e) {
    return pushWithRedirect(e)
  }

  function handleRedirectRecord(e) {
    const t = e.matched[e.matched.length - 1];
    if (t && t.redirect) {
      const {redirect: n} = t;
      let r = "function" == typeof n ? n(e) : n;
      return "string" == typeof r && (r = r.includes("?") || r.includes("#") ? r = locationAsObject(r) : {path: r}, r.params = {}), Et({
        query: e.query,
        hash: e.hash,
        params: e.params
      }, r)
    }
  }

  function pushWithRedirect(e, t) {
    const n = c = resolve2(e), o = l.value, s = e.state, a = e.force, i = !0 === e.replace, u = handleRedirectRecord(n);
    if (u) return pushWithRedirect(Et(locationAsObject(u), {state: s, force: a, replace: i}), t || n);
    const f = n;
    let p;
    return f.redirectedFrom = t, !a && function isSameRouteLocation(e, t, n) {
      let r = t.matched.length - 1, o = n.matched.length - 1;
      return r > -1 && r === o && isSameRouteRecord(t.matched[r], n.matched[o]) && isSameRouteLocationParams(t.params, n.params) && e(t.query) === e(n.query) && t.hash === n.hash
    }(r, o, n) && (p = createRouterError(16, {
      to: f,
      from: o
    }), handleScroll(o, o, !0, !1)), (p ? Promise.resolve(p) : navigate(f, o)).catch((e => isNavigationFailure(e) ? e : triggerError(e, f, o))).then((e => {
      if (e) {
        if (isNavigationFailure(e, 2)) return pushWithRedirect(Et(locationAsObject(e.to), {
          state: s,
          force: a,
          replace: i
        }), t || f)
      } else e = finalizeNavigation(f, o, !0, i, s);
      return triggerAfterEach(f, o, e), e
    }))
  }

  function checkCanceledNavigationAndReject(e, t) {
    const n = checkCanceledNavigation(e, t);
    return n ? Promise.reject(n) : Promise.resolve()
  }

  function navigate(e, t) {
    let n;
    const [r, o, i] = function extractChangingRecords(e, t) {
      const n = [], r = [], o = [], s = Math.max(t.matched.length, e.matched.length);
      for (let a = 0; a < s; a++) {
        const s = t.matched[a];
        s && (e.matched.find((e => isSameRouteRecord(e, s))) ? r.push(s) : n.push(s));
        const i = e.matched[a];
        i && (t.matched.find((e => isSameRouteRecord(e, i))) || o.push(i))
      }
      return [n, r, o]
    }(e, t);
    n = extractComponentsGuards(r.reverse(), "beforeRouteLeave", e, t);
    for (const s of r) s.leaveGuards.forEach((r => {
      n.push(guardToPromiseFn(r, e, t))
    }));
    const l = checkCanceledNavigationAndReject.bind(null, e, t);
    return n.push(l), runGuardQueue(n).then((() => {
      n = [];
      for (const r of s.list()) n.push(guardToPromiseFn(r, e, t));
      return n.push(l), runGuardQueue(n)
    })).then((() => {
      n = extractComponentsGuards(o, "beforeRouteUpdate", e, t);
      for (const r of o) r.updateGuards.forEach((r => {
        n.push(guardToPromiseFn(r, e, t))
      }));
      return n.push(l), runGuardQueue(n)
    })).then((() => {
      n = [];
      for (const r of e.matched) if (r.beforeEnter && !t.matched.includes(r)) if (Array.isArray(r.beforeEnter)) for (const o of r.beforeEnter) n.push(guardToPromiseFn(o, e, t)); else n.push(guardToPromiseFn(r.beforeEnter, e, t));
      return n.push(l), runGuardQueue(n)
    })).then((() => (e.matched.forEach((e => e.enterCallbacks = {})), n = extractComponentsGuards(i, "beforeRouteEnter", e, t), n.push(l), runGuardQueue(n)))).then((() => {
      n = [];
      for (const r of a.list()) n.push(guardToPromiseFn(r, e, t));
      return n.push(l), runGuardQueue(n)
    })).catch((e => isNavigationFailure(e, 8) ? e : Promise.reject(e)))
  }

  function triggerAfterEach(e, t, n) {
    for (const r of i.list()) r(e, t, n)
  }

  function finalizeNavigation(e, t, n, r, s) {
    const a = checkCanceledNavigation(e, t);
    if (a) return a;
    const i = t === It, c = St ? history.state : {};
    n && (r || i ? o.replace(e.fullPath, Et({scroll: i && c && c.scroll}, s)) : o.push(e.fullPath, s)), l.value = e, handleScroll(e, t, n, i), markAsReady()
  }

  let d;

  function setupListeners() {
    d = o.listen(((e, t, n) => {
      let r = resolve2(e);
      const s = handleRedirectRecord(r);
      if (s) return void pushWithRedirect(Et(s, {replace: !0}), r).catch(noop$1);
      c = r;
      const a = l.value;
      St && function saveScrollPosition(e, t) {
        Nt.set(e, t)
      }(getScrollKey(a.fullPath, n.delta), computeScrollPosition()), navigate(r, a).catch((e => isNavigationFailure(e, 12) ? e : isNavigationFailure(e, 2) ? (pushWithRedirect(e.to, r).then((e => {
        isNavigationFailure(e, 20) && !n.delta && n.type === At.pop && o.go(-1, !1)
      })).catch(noop$1), Promise.reject()) : (n.delta && o.go(-n.delta, !1), triggerError(e, r, a)))).then((e => {
        (e = e || finalizeNavigation(r, a, !1)) && (n.delta ? o.go(-n.delta, !1) : n.type === At.pop && isNavigationFailure(e, 20) && o.go(-1, !1)), triggerAfterEach(r, a, e)
      })).catch(noop$1)
    }))
  }

  let m, g = useCallbacks(), v = useCallbacks();

  function triggerError(e, t, n) {
    markAsReady(e);
    const r = v.list();
    return r.length ? r.forEach((r => r(e, t, n))) : console.error(e), Promise.reject(e)
  }

  function markAsReady(e) {
    m || (m = !0, setupListeners(), g.list().forEach((([t, n]) => e ? n(e) : t())), g.reset())
  }

  function handleScroll(t, n, r, o) {
    const {scrollBehavior: s} = e;
    if (!St || !s) return Promise.resolve();
    let a = !r && function getSavedScrollPosition(e) {
      const t = Nt.get(e);
      return Nt.delete(e), t
    }(getScrollKey(t.fullPath, 0)) || (o || !r) && history.state && history.state.scroll || null;
    return nextTick().then((() => s(t, n, a))).then((e => e && scrollToPosition(e))).catch((e => triggerError(e, t, n)))
  }

  const go = e => o.go(e);
  let y;
  const b = new Set;
  return {
    currentRoute: l,
    addRoute: function addRoute(e, n) {
      let r, o;
      return isRouteName(e) ? (r = t.getRecordMatcher(e), o = n) : o = e, t.addRoute(o, r)
    },
    removeRoute: function removeRoute(e) {
      let n = t.getRecordMatcher(e);
      n && t.removeRoute(n)
    },
    hasRoute: function hasRoute(e) {
      return !!t.getRecordMatcher(e)
    },
    getRoutes: function getRoutes() {
      return t.getRoutes().map((e => e.record))
    },
    resolve: resolve2,
    options: e,
    push,
    replace: function replace(e) {
      return push(Et(locationAsObject(e), {replace: !0}))
    },
    go,
    back: () => go(-1),
    forward: () => go(1),
    beforeEach: s.add,
    beforeResolve: a.add,
    afterEach: i.add,
    onError: v.add,
    isReady: function isReady() {
      return m && l.value !== It ? Promise.resolve() : new Promise(((e, t) => {
        g.add([e, t])
      }))
    },
    install(e) {
      e.component("RouterLink", nn), e.component("RouterView", rn), e.config.globalProperties.$router = this, Object.defineProperty(e.config.globalProperties, "$route", {
        enumerable: !0,
        get: () => unref(l)
      }), St && !y && l.value === It && (y = !0, push(o.location).catch((e => {
      })));
      const t = {};
      for (let r in It) t[r] = computed((() => l.value[r]));
      e.provide(_t, this), e.provide(kt, reactive(t)), e.provide(xt, l);
      let n = e.unmount;
      b.add(e), e.unmount = function () {
        b.delete(e), b.size < 1 && (d(), l.value = It, y = !1, m = !1), n()
      }
    }
  }
}

function runGuardQueue(e) {
  return e.reduce(((e, t) => e.then((() => t()))), Promise.resolve())
}

function useRouter() {
  return inject(_t)
}

const on = withScopeId();
pushScopeId("data-v-e074732a");
const sn = {class: "bg-[#080808] h-full"},
  an = {class: "w-10/12 sm:w-9/12 lg:w-8/12 xl:w-7/12 2xl:w-6/12 h-auto relative header-img mx-auto"},
  ln = {class: "w-30 sm:w-40 relative top-15/100 mx-auto"}, cn = De("button", {
    type: "button",
    class: "my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-red-600 hover:bg-red-700 focus:ring-red-500 focus:ring-offset-red-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg "
  }, " Start ", -1), un = De("a", {
    href: "https://babaiswiki.fandom.com/wiki/Baba_Is_You_Wiki",
    target: "_blank",
    rel: "noreferrer noopener"
  }, [De("button", {
    type: "button",
    class: "my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-blue-600 hover:bg-blue-700 focus:ring-blue-500 focus:ring-offset-blue-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg "
  }, " Wiki ")], -1),
  fn = De("footer", {class: "bottom-5 absolute w-full select-none cursor-default"}, [De("p", {class: "text-white text-center font-extrabold"}, " Origin game by ARVI TEIKARI "), De("p", {class: "text-white text-center font-extrabold"}, " Re-implemented by Xanonymous & Ricky ")], -1);
popScopeId();
const pn = defineComponent({
  expose: [], setup: n => (n, r) => {
    const o = resolveComponent("router-link");
    return openBlock(), createBlock("div", sn, [De("div", {
      class: "absolute bg-white h-full w-full opacity-70",
      style: {backgroundImage: `url('${unref(t)}')`}
    }, null, 4), De("header", an, [De("img", {
      src: unref(e),
      alt: "",
      loading: "lazy",
      class: "w-full"
    }, null, 8, ["src"])]), De("div", ln, [De(o, {to: {name: "Level"}}, {default: on((() => [cn])), _: 1}), un]), fn])
  }
});
pn.__scopeId = "data-v-e074732a";
const dn = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: pn});
const hn = "undefined" != typeof window, noop = () => {
};
const bypassFilter = e => e();

function watchWithFilter(e, t, n = {}) {
  const {eventFilter: r = bypassFilter} = n, o = function __rest(e, t) {
    var n = {};
    for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
    if (null != e && "function" == typeof Object.getOwnPropertySymbols) {
      var o = 0;
      for (r = Object.getOwnPropertySymbols(e); o < r.length; o++) t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]])
    }
    return n
  }(n, ["eventFilter"]);
  return watch(e, function createFilterWrapper(e, t) {
    return function wrapper(...n) {
      e((() => t.apply(this, n)), {fn: t, thisArg: this, args: n})
    }
  }(r, t), o)
}

function tryOnMounted(e, t = !0) {
  getCurrentInstance() ? ke(e) : t ? e() : nextTick(e)
}

const mn = hn ? window : void 0, gn = hn ? window.document : void 0;

function createGlobalState(e) {
  let t;
  return () => (null == t && (t = function withScope(e) {
    let t = null;
    if (gn) {
      const n = gn.createElement("div");
      createApp({
        setup() {
          t = reactive(e())
        }, render: () => null
      }).mount(n)
    } else t = reactive(e());
    return t
  }(e)), t)
}

function useEventListener(...e) {
  let t, n, r, o;
  if ("string" == typeof e[0] ? ([n, r, o] = e, t = mn) : [t, n, r, o] = e, !t) return noop;
  let s = noop;
  const a = watch((() => unref(t)), (e => {
    s(), e && (e.addEventListener(n, r, o), s = () => {
      e.removeEventListener(n, r, o), s = noop
    })
  }), {immediate: !0, flush: "post"}), stop2 = () => {
    a(), s()
  };
  return function tryOnUnmounted(e) {
    getCurrentInstance() && Ce(e)
  }(stop2), stop2
}

const vn = {
  boolean: {read: e => null != e ? "true" === e : null, write: e => String(e)},
  object: {read: e => e ? JSON.parse(e) : null, write: e => JSON.stringify(e)},
  number: {read: e => null != e ? Number.parseFloat(e) : null, write: e => String(e)},
  any: {read: e => null != e ? e : null, write: e => String(e)},
  string: {read: e => null != e ? e : null, write: e => String(e)}
};
var yn, bn;

function useSessionStorage(e, t, n = {}) {
  const {window: r = mn} = n;
  return function useStorage(e, t, n = (null == mn ? void 0 : mn.localStorage), r = {}) {
    var o;
    const {flush: s = "pre", deep: a = !0, listenToStorageChanges: i = !0, window: l = mn, eventFilter: c} = r,
      u = ref(t),
      f = null == t ? "any" : "boolean" == typeof t ? "boolean" : "string" == typeof t ? "string" : "object" == typeof t || Array.isArray(t) ? "object" : Number.isNaN(t) ? "any" : "number",
      p = null !== (o = r.serializer) && void 0 !== o ? o : vn[f];

    function read(r) {
      if (n && (!r || r.key === e)) try {
        const o = r ? r.newValue : n.getItem(e);
        null == o ? (u.value = t, n.setItem(e, p.write(t))) : u.value = p.read(o)
      } catch (o) {
        console.warn(o)
      }
    }

    return read(), l && i && useEventListener(l, "storage", read), watchWithFilter(u, (() => {
      if (n) try {
        null == u.value ? n.removeItem(e) : n.setItem(e, p.write(u.value))
      } catch (t) {
        console.warn(t)
      }
    }), {flush: s, deep: a, eventFilter: c}), u
  }(e, t, null == r ? void 0 : r.sessionStorage, n)
}

(bn = yn || (yn = {})).UP = "UP", bn.RIGHT = "RIGHT", bn.DOWN = "DOWN", bn.LEFT = "LEFT", bn.NONE = "NONE", pushScopeId("data-v-1d5c4582");
const Rn = {class: "flex\n        animate-bg\n        h-full\n        justify-center\n        relative\n        flex-col\n        bg-gray-900"},
  wn = {class: "card-container w-4/5 relative mx-auto my-auto"};
popScopeId();
const _n = defineComponent({
  expose: [], setup(e) {
    const t = useRouter(), o = r();
    return (e, r) => (openBlock(), createBlock("div", Rn, [De("div", wn, [(openBlock(!0), createBlock(Le, null, renderList(unref(n), ((e, n) => (openBlock(), createBlock("button", {
      key: n,
      type: "button",
      class: "w-60 h-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-red-600 hover:bg-red-700 focus:ring-red-500 focus:ring-offset-red-200 text-white transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg",
      onClick: withModifiers((n => (async e => {
        o.value.currentLevel = e, await t.push({name: "Game"})
      })(e)), ["stop", "prevent"])
    }, toDisplayString(e.name), 9, ["onClick"])))), 128))]), De("button", {
      type: "button",
      class: "relative mx-auto my-10 w-45 h-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-white hover:bg-gray-400 text-black transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg",
      onClick: r[1] || (r[1] = withModifiers((e => unref(t).push({name: "Home"})), ["stop", "prevent"]))
    }, " Back To Home ")]))
  }
});
_n.__scopeId = "data-v-1d5c4582";
const kn = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: _n});
pushScopeId("data-v-5237a132");
const xn = {
  id: "game-layer",
  class: "\n       transform-gpu\n        flex\n        h-screen\n        justify-center\n        relative\n        bg-gray-900"
};
popScopeId();
const Sn = defineComponent({
  expose: [], setup(e) {
    const t = r(), n = useRouter(), c = ref({}), u = ref(!1), f = ref(!1), p = ref(0), d = ref(0), m = ref(l.GENERAL),
      g = defineAsyncComponent((() => o((() => Promise.resolve().then((function () {
        return Tn
      }))), void 0))), v = defineAsyncComponent((() => o((() => Promise.resolve().then((function () {
        return Mn
      }))), void 0)));
    let y;
    const b = document.createElement("audio"), gamePause = () => {
      y.pause()
    }, handleEsc = e => {
      null == e || e.preventDefault(), null == e || e.stopImmediatePropagation(), null == e || e.stopPropagation(), p.value++, u.value = !u.value, u.value ? gamePause() : (y.resume(), m.value = l.GENERAL)
    }, handleR = e => {
      e.preventDefault(), e.stopImmediatePropagation(), e.stopPropagation(), m.value = l.RESTART, p.value++, gamePause(), u.value = !0
    }, startNewGame = async () => {
      const e = t.value.currentLevel.setupFileName;
      var n;
      e && (await y.startLevel(e.trim()), f.value = !1, i.bind("esc", handleEsc), i.bind("r", handleR), n = t.value.currentLevel.backgroundMusic, b.src = "/music/" + n, b.loop = !0, await b.play())
    }, gameOver = async e => {
      switch (e) {
        case a.WIN:
          m.value = l.WIN, p.value++, i.unbind(["esc", "r"]), u.value = !0, await b.pause();
          break;
        case a.RESTART:
          await startNewGame()
      }
    }, handleYouGone = async e => {
      b.pause(), e || d.value++, f.value = !e
    }, restartGame = () => {
      handleEsc(), startNewGame()
    }, toMenu = async () => {
      b.pause(), await n.replace({name: "Level"})
    }, toHome = async () => {
      b.pause(), await n.replace({name: "Home"})
    };
    return tryOnMounted((async () => {
      y = await (async () => await s)(), y.setGameOverOutsideHandler(gameOver), y.setYouGoneOutsideHandler(handleYouGone), c.value.appendChild(y.gameView), await startNewGame()
    })), (e, t) => (openBlock(), createBlock(Le, null, [u.value ? (openBlock(), createBlock(unref(g), {
      key: "menu" + p.value,
      mode: m.value,
      onResume: handleEsc,
      onRestart: restartGame,
      onToMenu: toMenu,
      onToHome: toHome
    }, null, 8, ["mode"])) : createCommentVNode("", !0), f.value ? (openBlock(), createBlock(unref(v), {key: "alertBar" + d.value})) : createCommentVNode("", !0), De("div", xn, [De("div", {
      ref: c,
      class: "\n         game-layer\n         self-center"
    }, null, 512)])], 64))
  }
});
Sn.__scopeId = "data-v-5237a132";
const En = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: Sn}),
  Cn = {class: "bg-gray-900 opacity-95 w-full h-full fixed z-30"},
  An = {key: 1, class: "my-30 w-full text-white font-extrabold text-xl md:text-3xl text-center"},
  On = {class: "w-70 sm:w-60 relative mx-auto"}, Pn = defineComponent({
    expose: [],
    props: {mode: {type: String, required: !1, default: l.GENERAL}},
    emits: ["resume", "restart", "toMenu", "toHome"],
    setup(e, {emit: t}) {
      const n = e, r = defineAsyncComponent((() => o((() => Promise.resolve().then((function () {
        return Ln
      }))), void 0))), s = ref({});
      return tryOnMounted((() => {
        n.mode !== l.WIN && s.value.focus()
      })), (n, o) => (openBlock(), createBlock("div", Cn, [e.mode === unref(l).WIN ? (openBlock(), createBlock(unref(r), {
        key: 0,
        class: "w-full relative"
      })) : createCommentVNode("", !0), e.mode === unref(l).RESTART ? (openBlock(), createBlock("p", An, " ARE YOU SURE YOU WANT TO RESTART? ")) : createCommentVNode("", !0), De("div", On, [withDirectives(De("button", {
        ref: s,
        type: "button",
        class: "opacity-100 my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-green-500 hover:bg-green-600 focus:ring-green-500 focus:ring-offset-blue-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg ",
        onClick: o[1] || (o[1] = withModifiers((e => t("resume")), ["prevent", "stop"]))
      }, toDisplayString(e.mode !== unref(l).RESTART ? "RESUME" : "No"), 513), [[mt, e.mode !== unref(l).WIN]]), De("button", {
        type: "button",
        class: "opacity-100 my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-green-500 hover:bg-green-600 focus:ring-green-500 focus:ring-offset-blue-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg ",
        onClick: o[2] || (o[2] = withModifiers((e => t("restart")), ["prevent", "stop"]))
      }, toDisplayString(e.mode !== unref(l).RESTART ? "RESTART" : "Yes"), 1), withDirectives(De("button", {
        type: "button",
        class: "opacity-100 my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-green-500 hover:bg-green-600 focus:ring-green-500 focus:ring-offset-blue-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg ",
        onClick: o[3] || (o[3] = withModifiers((e => t("toMenu")), ["prevent", "stop"]))
      }, " RETURN TO MENU ", 512), [[mt, e.mode !== unref(l).RESTART]]), withDirectives(De("button", {
        type: "button",
        class: "opacity-100 my-10 py-1 px-2 sm:py-2 sm:px-4 flex justify-center items-center bg-green-500 hover:bg-green-600 focus:ring-green-500 focus:ring-offset-blue-200 text-white w-full transition ease-in duration-200 text-center text-base font-semibold shadow-md focus:outline-none focus:ring-2 focus:ring-offset-2 rounded-lg ",
        onClick: o[4] || (o[4] = withModifiers((e => t("toHome")), ["prevent", "stop"]))
      }, " RETURN TO HOME ", 512), [[mt, e.mode !== unref(l).RESTART]])])]))
    }
  }), Tn = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: Pn});
pushScopeId("data-v-8eafb272");
const jn = {class: "bg-grey-900 opacity-65 w-full h-full fixed z-20"},
  Nn = {class: "bg-white rounded-lg w-10/12 h-50 fixed abs-center fixed animate-pulse"};
popScopeId();
const In = defineComponent({
  expose: [],
  setup: e => (e, t) => (openBlock(), createBlock("div", jn, [De("div", Nn, [De("img", {
    src: unref(c),
    alt: "",
    class: "mx-auto top-[30%] relative invert animate-bounce max-w-full"
  }, null, 8, ["src"])])]))
});
In.__scopeId = "data-v-8eafb272";
const Mn = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: In}), Fn = defineComponent({
  expose: [],
  setup: e => (e, t) => (openBlock(), createBlock("img", {src: unref(u), alt: "Congratulations"}, null, 8, ["src"]))
}), Ln = Object.freeze({__proto__: null, [Symbol.toStringTag]: "Module", default: Fn});
export {
  En as G,
  dn as H,
  kn as L,
  yt as _,
  createRouter as a,
  createWebHistory as b,
  createApp as c,
  createGlobalState as d,
  useSessionStorage as u
};
